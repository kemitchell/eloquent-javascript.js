{
  "content": [
    {
      "element": "blockquote",
      "attribution": "Marcus Aurelius Meditations",
      "content": [
        {
          "element": "p",
          "content": [
            "You have power over your mind—not outside events. Realize this, and you will find strength."
          ]
        }
      ]
    },
    {
      "element": "p",
      "content": [
        "Some programs work with direct user input, such as mouse and keyboard interaction. The timing and order of such input can’t be predicted in advance. This requires a different approach to control flow than the one we have used so far."
      ]
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "Imagine an interface where the only way to find out whether a key on the keyboard is being pressed is to read the current state of that key. To be able to react to keypresses, you would have to constantly read the key’s state so that you’d catch it before it’s released again. It would be dangerous to perform other time-intensive computations since you might miss a keypress."
          ]
        },
        {
          "element": "p",
          "content": [
            "That is how such input was handled on primitive machines. A step up would be for the hardware or operating system to notice the keypress and put it in a queue. A program can then periodically check the queue for new events and react to what it finds there."
          ]
        },
        {
          "element": "p",
          "content": [
            "Of course, it has to remember to look at the queue, and to do it often, because any time between the key being pressed and the program noticing the event will cause the software to feel unresponsive. This approach is called ",
            {
              "element": "em",
              "content": [
                "polling"
              ]
            },
            ". Most programmers avoid it whenever possible."
          ]
        },
        {
          "element": "p",
          "content": [
            "A better mechanism is for the underlying system to give our code a chance to react to events as they occur. Browsers do this by allowing us to register functions as ",
            {
              "element": "em",
              "content": [
                "handlers"
              ]
            },
            " for specific events."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": []
        },
        {
          "element": "p",
          "content": [
            "The ",
            {
              "element": "literal",
              "content": [
                "addEventListener"
              ]
            },
            " function registers its second argument to be called whenever the event described by its first argument occurs."
          ]
        }
      ],
      "title": "Event handlers"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "Each browser event handler is registered in a context. When you call ",
            {
              "element": "literal",
              "content": [
                "addEventListener"
              ]
            },
            " as shown previously, you are calling it as a method on the whole window because in the browser the global scope is equivalent to the ",
            {
              "element": "literal",
              "content": [
                "window"
              ]
            },
            " object. Every DOM element has its own ",
            {
              "element": "literal",
              "content": [
                "addEventListener"
              ]
            },
            " method, which allows you to listen specifically on that element."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": []
        },
        {
          "element": "p",
          "content": [
            "The example attaches a handler to the button node. Thus, clicks on the button cause that handler to run, whereas clicks on the rest of the document do not."
          ]
        },
        {
          "element": "p",
          "content": [
            "Giving a node an ",
            {
              "element": "literal",
              "content": [
                "onclick"
              ]
            },
            " attribute has a similar effect. But a node has only one ",
            {
              "element": "literal",
              "content": [
                "onclick"
              ]
            },
            " attribute, so you can register only one handler per node that way. The ",
            {
              "element": "literal",
              "content": [
                "addEventListener"
              ]
            },
            " method allows you to add any number of handlers, so you can’t accidentally replace a handler that has already been registered."
          ]
        },
        {
          "element": "p",
          "content": [
            "The ",
            {
              "element": "literal",
              "content": [
                "removeEventListener"
              ]
            },
            " method, called with arguments similar to as ",
            {
              "element": "literal",
              "content": [
                "addEventListener"
              ]
            },
            ", removes a handler."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": []
        },
        {
          "element": "p",
          "content": [
            " To be able to unregister a handler function, we give it a name (such as ",
            {
              "element": "literal",
              "content": [
                "once"
              ]
            },
            ") so that we can pass it to both ",
            {
              "element": "literal",
              "content": [
                "addEventListener"
              ]
            },
            " and ",
            {
              "element": "literal",
              "content": [
                "removeEventListener"
              ]
            },
            "."
          ]
        }
      ],
      "title": "Events and DOM nodes"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "Though we have ignored it in the previous examples, event handler functions are passed an argument: the ",
            {
              "element": "em",
              "content": [
                "event object"
              ]
            },
            ". This object gives us additional information about the event. For example, if we want to know ",
            {
              "element": "em",
              "content": [
                "which"
              ]
            },
            " mouse button was pressed, we can look at the event object’s ",
            {
              "element": "literal",
              "content": [
                "which"
              ]
            },
            " property."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": []
        },
        {
          "element": "p",
          "content": [
            "The information stored in an event object differs per type of event. We’ll discuss various types later in this chapter. The object’s ",
            {
              "element": "literal",
              "content": [
                "type"
              ]
            },
            " property always holds a string identifying the event (for example ",
            {
              "element": "literal",
              "content": [
                "\"click\""
              ]
            },
            " or ",
            {
              "element": "literal",
              "content": [
                "\"mousedown\""
              ]
            },
            ")."
          ]
        }
      ],
      "title": "Event objects"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "Event handlers registered on nodes with children will also receive some events that happen in the children. If a button inside a paragraph is clicked, event handlers on the paragraph will also receive the click event."
          ]
        },
        {
          "element": "p",
          "content": [
            "But if both the paragraph and the button have a handler, the more specific handler—the one on the button—gets to go first. The event is said to ",
            {
              "element": "em",
              "content": [
                "propagate"
              ]
            },
            " outward, from the node where it happened to that node’s parent node and on to the root of the document. Finally, after all handlers registered on a specific node have had their turn, handlers registered on the whole window get a chance to respond to the event."
          ]
        },
        {
          "element": "p",
          "content": [
            "At any point, an event handler can call the ",
            {
              "element": "literal",
              "content": [
                "stopPropagation"
              ]
            },
            " method on the event object to prevent handlers “further up” from receiving the event. This can be useful when, for example, you have a button inside another clickable element and you don’t want clicks on the button to activate the outer element’s click behavior."
          ]
        },
        {
          "element": "p",
          "content": [
            "The following example registers ",
            {
              "element": "literal",
              "content": [
                "\"mousedown\""
              ]
            },
            " handlers on both a button and the paragraph around it. When clicked with the right mouse button, the handler for the button calls ",
            {
              "element": "literal",
              "content": [
                "stopPropagation"
              ]
            },
            ", which will prevent the handler on the paragraph from running. When the button is clicked with another mouse button, both handlers will run."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": []
        },
        {
          "element": "p",
          "content": [
            "Most event objects have a ",
            {
              "element": "literal",
              "content": [
                "target"
              ]
            },
            " property that refers to the node where they originated. You can use this property to ensure that you’re not accidentally handling something that propagated up from a node you do not want to handle."
          ]
        },
        {
          "element": "p",
          "content": [
            "It is also possible to use the ",
            {
              "element": "literal",
              "content": [
                "target"
              ]
            },
            " property to cast a wide net for a specific type of event. For example, if you have a node containing a long list of buttons, it may be more convenient to register a single click handler on the outer node and have it use the ",
            {
              "element": "literal",
              "content": [
                "target"
              ]
            },
            " property to figure out whether a button was clicked, rather than register individual handlers on all of the buttons."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": []
        }
      ],
      "title": "Propagation"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "Many events have a default action associated with them. If you click a link, you will be taken to the link’s target. If you press the down arrow, the browser will scroll the page down. If you right-click, you’ll get a context menu. And so on."
          ]
        },
        {
          "element": "p",
          "content": [
            "For most types of events, the JavaScript event handlers are called ",
            {
              "element": "em",
              "content": [
                "before"
              ]
            },
            " the default behavior is performed. If the handler doesn’t want the normal behavior to happen, typically because it has already taken care of handling the event, it can call the ",
            {
              "element": "literal",
              "content": [
                "preventDefault"
              ]
            },
            " method on the event object."
          ]
        },
        {
          "element": "p",
          "content": [
            "This can be used to implement your own keyboard shortcuts or context menu. It can also be used to obnoxiously interfere with the behavior that users expect. For example, here is a link that cannot be followed:"
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": []
        },
        {
          "element": "p",
          "content": [
            "Try not to do such things unless you have a really good reason to. For people using your page, it can be unpleasant when the behavior they expect is broken."
          ]
        },
        {
          "element": "p",
          "content": [
            "Depending on the browser, some events can’t be intercepted. On Chrome, for example, keyboard shortcuts to close the current tab (Ctrl-W or Command-W) cannot be handled by JavaScript."
          ]
        }
      ],
      "title": "Default actions"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "When a key on the keyboard is pressed, your browser fires a ",
            {
              "element": "literal",
              "content": [
                "\"keydown\""
              ]
            },
            " event. When it is released, a ",
            {
              "element": "literal",
              "content": [
                "\"keyup\""
              ]
            },
            " event fires."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": []
        },
        {
          "element": "p",
          "content": [
            "Despite its name, ",
            {
              "element": "literal",
              "content": [
                "\"keydown\""
              ]
            },
            " fires not only when the key is physically pushed down. When a key is pressed and held, the event fires again every time the key ",
            {
              "element": "em",
              "content": [
                "repeats"
              ]
            },
            ". Sometimes—for example if you want to increase the acceleration of a game character when an arrow key is pressed and decrease it again when the key is released—you have to be careful not to increase it again every time the key repeats or you’d end up with unintentionally huge values."
          ]
        },
        {
          "element": "p",
          "content": [
            "The previous example looked at the ",
            {
              "element": "literal",
              "content": [
                "keyCode"
              ]
            },
            " property of the event object. This is how you can identify which key is being pressed or released. Unfortunately, it’s not always obvious how to translate the numeric key code to an actual key."
          ]
        },
        {
          "element": "p",
          "content": [
            "For letter and number keys, the associated key code will be the Unicode character code associated with the (uppercase) letter or number printed on the key. The ",
            {
              "element": "literal",
              "content": [
                "charCodeAt"
              ]
            },
            " method on strings gives us a way to find this code."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": []
        },
        {
          "element": "p",
          "content": [
            "Other keys have less predictable key codes. The best way to find the codes you need is usually by experimenting—register a key event handler that logs the key codes it gets and press the key you are interested in."
          ]
        },
        {
          "element": "p",
          "content": [
            "Modifier keys such as Shift, Ctrl, Alt, and Meta (Command on Mac) generate key events just like normal keys. But when looking for key combinations, you can also find out whether these keys are held down by looking at the ",
            {
              "element": "literal",
              "content": [
                "shiftKey"
              ]
            },
            ", ",
            {
              "element": "literal",
              "content": [
                "ctrlKey"
              ]
            },
            ", ",
            {
              "element": "literal",
              "content": [
                "altKey"
              ]
            },
            ", and ",
            {
              "element": "literal",
              "content": [
                "metaKey"
              ]
            },
            " properties of keyboard and mouse events."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": []
        },
        {
          "element": "p",
          "content": [
            "The ",
            {
              "element": "literal",
              "content": [
                "\"keydown\""
              ]
            },
            " and ",
            {
              "element": "literal",
              "content": [
                "\"keyup\""
              ]
            },
            " events give you information about the physical key that is being pressed. But what if you are interested in the actual text being typed? Getting that text from key codes is awkward. Instead, there exists another event, ",
            {
              "element": "literal",
              "content": [
                "\"keypress\""
              ]
            },
            ", which fires right after ",
            {
              "element": "literal",
              "content": [
                "\"keydown\""
              ]
            },
            " (and repeated along with ",
            {
              "element": "literal",
              "content": [
                "\"keydown\""
              ]
            },
            " when the key is held) but only for keys that produce character input. The ",
            {
              "element": "literal",
              "content": [
                "charCode"
              ]
            },
            " property in the event object contains a code that can be interpreted as a Unicode character code. We can use the ",
            {
              "element": "literal",
              "content": [
                "String.fromCharCode"
              ]
            },
            " function to turn this code into an actual single-character string."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": []
        },
        {
          "element": "p",
          "content": [
            " The DOM node where a key event originates depends on the element that has focus when the key is pressed. Normal nodes cannot have focus (unless you give them a ",
            {
              "element": "literal",
              "content": [
                "tabindex"
              ]
            },
            " attribute), but things such as links, buttons, and form fields can. We’ll come back to form fields in ",
            {
              "element": "reference",
              "content": "Chapter 18"
            },
            ". When nothing in particular has focus, ",
            {
              "element": "literal",
              "content": [
                "document.body"
              ]
            },
            " acts as the target node of key events."
          ]
        }
      ],
      "title": "Key events"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "Pressing a mouse button also causes a number of events to fire. The ",
            {
              "element": "literal",
              "content": [
                "\"mousedown\""
              ]
            },
            " and ",
            {
              "element": "literal",
              "content": [
                "\"mouseup\""
              ]
            },
            " events are similar to ",
            {
              "element": "literal",
              "content": [
                "\"keydown\""
              ]
            },
            " and ",
            {
              "element": "literal",
              "content": [
                "\"keyup\""
              ]
            },
            " and fire when the button is pressed and released. These will happen on the DOM nodes that are immediately below the mouse pointer when the event occurs."
          ]
        },
        {
          "element": "p",
          "content": [
            "After the ",
            {
              "element": "literal",
              "content": [
                "\"mouseup\""
              ]
            },
            " event, a ",
            {
              "element": "literal",
              "content": [
                "\"click\""
              ]
            },
            " event fires on the most specific node that contained both the press and the release of the button. For example, if I press down the mouse button on one paragraph and then move the pointer to another paragraph and release the button, the ",
            {
              "element": "literal",
              "content": [
                "\"click\""
              ]
            },
            " event will happen on the element that contains both those paragraphs."
          ]
        },
        {
          "element": "p",
          "content": [
            "If two clicks happen close together, a ",
            {
              "element": "literal",
              "content": [
                "\"dblclick\""
              ]
            },
            " (double-click) event also fires, after the second click event."
          ]
        },
        {
          "element": "p",
          "content": [
            "To get precise information about the place where a mouse event happened, you can look at its ",
            {
              "element": "literal",
              "content": [
                "pageX"
              ]
            },
            " and ",
            {
              "element": "literal",
              "content": [
                "pageY"
              ]
            },
            " properties, which contain the event’s coordinates (in pixels) relative to the top-left corner of the document."
          ]
        },
        {
          "element": "p",
          "content": [
            "The following implements a primitive drawing program. Every time you click the document, it adds a dot under your mouse pointer. See ",
            {
              "element": "reference",
              "content": "Chapter 19"
            },
            " for a less primitive drawing program."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": []
        },
        {
          "element": "p",
          "content": [
            "The ",
            {
              "element": "literal",
              "content": [
                "clientX"
              ]
            },
            " and ",
            {
              "element": "literal",
              "content": [
                "clientY"
              ]
            },
            " properties are similar to ",
            {
              "element": "literal",
              "content": [
                "pageX"
              ]
            },
            " and ",
            {
              "element": "literal",
              "content": [
                "pageY"
              ]
            },
            " but relative to the part of the document that is currently scrolled into view. These can be useful when comparing mouse coordinates with the coordinates returned by ",
            {
              "element": "literal",
              "content": [
                "getBoundingClientRect"
              ]
            },
            ", which also returns viewport-relative coordinates."
          ]
        }
      ],
      "title": "Mouse clicks"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "Every time the mouse pointer moves, a ",
            {
              "element": "literal",
              "content": [
                "\"mousemove\""
              ]
            },
            " event fires. This event can be used to track the position of the mouse. A common situation in which this is useful is when implementing some form of mouse-dragging functionality."
          ]
        },
        {
          "element": "p",
          "content": [
            "As an example, the following program displays a bar and sets up event handlers so that dragging to the left or right on this bar makes it narrower or wider:"
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": []
        },
        {
          "element": "p",
          "content": [
            "Note that the ",
            {
              "element": "literal",
              "content": [
                "\"mousemove\""
              ]
            },
            " handler is registered on the whole window. Even if the mouse goes outside of the bar during resizing, we still want to update its size and stop dragging when the mouse is released."
          ]
        },
        {
          "element": "p",
          "content": [
            "We must stop resizing the bar when the mouse button is released. Unfortunately, not all browsers give ",
            {
              "element": "literal",
              "content": [
                "\"mousemove\""
              ]
            },
            " events a meaningful ",
            {
              "element": "literal",
              "content": [
                "which"
              ]
            },
            " property. There is a standard property called ",
            {
              "element": "literal",
              "content": [
                "buttons"
              ]
            },
            ", which provides similar information, but that is also not supported on all browsers. Fortunately, all major browsers support either ",
            {
              "element": "literal",
              "content": [
                "buttons"
              ]
            },
            " or ",
            {
              "element": "literal",
              "content": [
                "which"
              ]
            },
            ", so the ",
            {
              "element": "literal",
              "content": [
                "buttonPressed"
              ]
            },
            " function in the example first tries ",
            {
              "element": "literal",
              "content": [
                "buttons"
              ]
            },
            ", and falls back to ",
            {
              "element": "literal",
              "content": [
                "which"
              ]
            },
            " when that isn’t available."
          ]
        },
        {
          "element": "p",
          "content": [
            "Whenever the mouse pointer enters or leaves a node, a ",
            {
              "element": "literal",
              "content": [
                "\"mouseover\""
              ]
            },
            " or ",
            {
              "element": "literal",
              "content": [
                "\"mouseout\""
              ]
            },
            " event fires. These two events can be used, among other things, to create hover effects, showing or styling something when the mouse is over a given element."
          ]
        },
        {
          "element": "p",
          "content": [
            "Unfortunately, creating such an effect is not as simple as starting the effect on ",
            {
              "element": "literal",
              "content": [
                "\"mouseover\""
              ]
            },
            " and ending it on ",
            {
              "element": "literal",
              "content": [
                "\"mouseout\""
              ]
            },
            ". When the mouse moves from a node onto one of its children, ",
            {
              "element": "literal",
              "content": [
                "\"mouseout\""
              ]
            },
            " fires on the parent node, though the mouse did not actually leave the node’s extent. To make things worse, these events propagate just like other events, and thus you will also receive ",
            {
              "element": "literal",
              "content": [
                "\"mouseout\""
              ]
            },
            " events when the mouse leaves one of the child nodes of the node on which the handler is registered."
          ]
        },
        {
          "element": "p",
          "content": [
            "To work around this problem, we can use the ",
            {
              "element": "literal",
              "content": [
                "relatedTarget"
              ]
            },
            " property of the event objects created for these events. It tells us, in the case of ",
            {
              "element": "literal",
              "content": [
                "\"mouseover\""
              ]
            },
            ", what element the pointer was over before and, in the case of ",
            {
              "element": "literal",
              "content": [
                "\"mouseout\""
              ]
            },
            ", what element it is going to. We want to change our hover effect only when the ",
            {
              "element": "literal",
              "content": [
                "relatedTarget"
              ]
            },
            " is outside of our target node. Only in that case does this event actually represent a ",
            {
              "element": "em",
              "content": [
                "crossing over"
              ]
            },
            " from outside to inside the node (or the other way around)."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": []
        },
        {
          "element": "p",
          "content": [
            "The ",
            {
              "element": "literal",
              "content": [
                "isInside"
              ]
            },
            " function follows the given node’s parent links until it either reaches the top of the document (when ",
            {
              "element": "literal",
              "content": [
                "node"
              ]
            },
            " becomes null) or finds the parent we are looking for."
          ]
        },
        {
          "element": "p",
          "content": [
            "I should add that a hover effect like this can be much more easily achieved using the CSS ",
            {
              "element": "em",
              "content": [
                "pseudoselector"
              ]
            },
            " ",
            {
              "element": "literal",
              "content": [
                ":hover"
              ]
            },
            ", as the next example shows. But when your hover effect involves doing something more complicated than changing a style on the target node, you must use the trick with ",
            {
              "element": "literal",
              "content": [
                "\"mouseover\""
              ]
            },
            " and ",
            {
              "element": "literal",
              "content": [
                "\"mouseout\""
              ]
            },
            " events."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": []
        }
      ],
      "title": "Mouse motion"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "Whenever an element is scrolled, a ",
            {
              "element": "literal",
              "content": [
                "\"scroll\""
              ]
            },
            " event fires on it. This has various uses, such as knowing what the user is currently looking at (for disabling off-screen animations or sending spy reports to your evil headquarters) or showing some indication of progress (by highlighting part of a table of contents or showing a page number)."
          ]
        },
        {
          "element": "p",
          "content": [
            "The following example draws a progress bar in the top-right corner of the document and updates it to fill up as you scroll down:"
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": []
        },
        {
          "element": "p",
          "content": [
            "Giving an element a ",
            {
              "element": "literal",
              "content": [
                "position"
              ]
            },
            " of ",
            {
              "element": "literal",
              "content": [
                "fixed"
              ]
            },
            " acts much like an ",
            {
              "element": "literal",
              "content": [
                "absolute"
              ]
            },
            " position but also prevents it from scrolling along with the rest of the document. The effect is to make our progress bar stay in its corner. Inside it is another element, which is resized to indicate the current progress. We use ",
            {
              "element": "literal",
              "content": [
                "%"
              ]
            },
            ", rather than ",
            {
              "element": "literal",
              "content": [
                "px"
              ]
            },
            ", as a unit when setting the width so that the element is sized relative to the whole bar."
          ]
        },
        {
          "element": "p",
          "content": [
            "The global ",
            {
              "element": "literal",
              "content": [
                "innerHeight"
              ]
            },
            " variable gives us the height of the window, which we have to subtract from the total scrollable height—you can’t keep scrolling when you hit the bottom of the document. (There’s also an ",
            {
              "element": "literal",
              "content": [
                "innerWidth"
              ]
            },
            " to go along with ",
            {
              "element": "literal",
              "content": [
                "innerHeight"
              ]
            },
            ".) By dividing ",
            {
              "element": "literal",
              "content": [
                "pageYOffset"
              ]
            },
            ", the current scroll position, by the maximum scroll position and multiplying by 100, we get the percentage for the progress bar."
          ]
        },
        {
          "element": "p",
          "content": [
            "Calling ",
            {
              "element": "literal",
              "content": [
                "preventDefault"
              ]
            },
            " on a scroll event does not prevent the scrolling from happening. In fact, the event handler is called only ",
            {
              "element": "em",
              "content": [
                "after"
              ]
            },
            " the scrolling takes place."
          ]
        }
      ],
      "title": "Scroll events"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "When an element gains focus, the browser fires a ",
            {
              "element": "literal",
              "content": [
                "\"focus\""
              ]
            },
            " event on it. When it loses focus, a ",
            {
              "element": "literal",
              "content": [
                "\"blur\""
              ]
            },
            " event fires."
          ]
        },
        {
          "element": "p",
          "content": [
            "Unlike the events discussed earlier, these two events do not propagate. A handler on a parent element is not notified when a child element gains or loses focus."
          ]
        },
        {
          "element": "p",
          "content": [
            "The following example displays help text for the text field that currently has focus:"
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": []
        },
        {
          "element": "p",
          "content": [
            "The window object will receive ",
            {
              "element": "literal",
              "content": [
                "\"focus\""
              ]
            },
            " and ",
            {
              "element": "literal",
              "content": [
                "\"blur\""
              ]
            },
            " events when the user moves from or to the browser tab or window in which the document is shown."
          ]
        }
      ],
      "title": "Focus events"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "When a page finishes loading, the ",
            {
              "element": "literal",
              "content": [
                "\"load\""
              ]
            },
            " event fires on the window and the document body objects. This is often used to schedule initialization actions that require the whole document to have been built. Remember that the content of ",
            {
              "element": "literal",
              "content": [
                "<",
                "script",
                ">"
              ]
            },
            " tags is run immediately when the tag is encountered. This is often too soon, such as when the script needs to do something with parts of the document that appear after the ",
            {
              "element": "literal",
              "content": [
                "<",
                "script",
                ">"
              ]
            },
            " tag."
          ]
        },
        {
          "element": "p",
          "content": [
            "Elements such as images and script tags that load an external file also have a ",
            {
              "element": "literal",
              "content": [
                "\"load\""
              ]
            },
            " event that indicates the files they reference were loaded. Like the focus-related events, loading events do not propagate."
          ]
        },
        {
          "element": "p",
          "content": [
            "When a page is closed or navigated away from (for example by following a link), a ",
            {
              "element": "literal",
              "content": [
                "\"beforeunload\""
              ]
            },
            " event fires. The main use of this event is to prevent the user from accidentally losing work by closing a document. Preventing the page from unloading is not, as you might expect, done with the ",
            {
              "element": "literal",
              "content": [
                "preventDefault"
              ]
            },
            " method. Instead, it is done by returning a string from the handler. The string will be used in a dialog that asks the user if they want to stay on the page or leave it. This mechanism ensures that a user is able to leave the page, even if it is running a malicious script that would prefer to keep them there forever in order to force them to look at dodgy weight loss ads."
          ]
        }
      ],
      "title": "Load event"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "There are various things that can cause a script to start executing. Reading a ",
            {
              "element": "literal",
              "content": [
                "<",
                "script",
                ">"
              ]
            },
            " tag is one such thing. An event firing is another. ",
            {
              "element": "reference",
              "content": "Chapter 13"
            },
            " discussed the ",
            {
              "element": "literal",
              "content": [
                "requestAnimationFrame"
              ]
            },
            " function, which schedules a function to be called before the next page redraw. That is yet another way in which a script can start running."
          ]
        },
        {
          "element": "p",
          "content": [
            "It is important to understand that even though events can fire at any time, no two scripts in a single document ever run at the same moment. If a script is already running, event handlers and pieces of code scheduled in other ways have to wait for their turn. This is the reason why a document will freeze when a script runs for a long time. The browser cannot react to clicks and other events inside the document because it can’t run event handlers until the current script finishes running."
          ]
        },
        {
          "element": "p",
          "content": [
            "Some programming environments do allow multiple ",
            {
              "element": "em",
              "content": [
                "threads of execution"
              ]
            },
            " to run at the same time. Doing multiple things at the same time can be used to make a program faster. But when you have multiple actors touching the same parts of the system at the same time, thinking about a program becomes at least an order of magnitude harder."
          ]
        },
        {
          "element": "p",
          "content": [
            "The fact that JavaScript programs do only one thing at a time makes our lives easier. For cases where you ",
            {
              "element": "em",
              "content": [
                "really"
              ]
            },
            " do want to do some time-consuming thing in the background without freezing the page, browsers provide something called ",
            {
              "element": "em",
              "content": [
                "web workers"
              ]
            },
            ". A worker is an isolated JavaScript environment that runs alongside the main program for a document and can communicate with it only by sending and receiving messages."
          ]
        },
        {
          "element": "p",
          "content": [
            "Assume we have the following code in a file called ",
            {
              "element": "literal",
              "content": [
                "code/squareworker.js"
              ]
            },
            ":"
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": []
        },
        {
          "element": "p",
          "content": [
            "Imagine that squaring a number is a heavy, long-running computation that we want to perform in a background thread. This code spawns a worker, sends it a few messages, and outputs the responses."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": []
        },
        {
          "element": "p",
          "content": [
            "The ",
            {
              "element": "literal",
              "content": [
                "postMessage"
              ]
            },
            " function sends a message, which will cause a ",
            {
              "element": "literal",
              "content": [
                "\"message\""
              ]
            },
            " event to fire in the receiver. The script that created the worker sends and receives messages through the ",
            {
              "element": "literal",
              "content": [
                "Worker"
              ]
            },
            " object, whereas the worker talks to the script that created it by sending and listening directly on its global scope—which is a ",
            {
              "element": "em",
              "content": [
                "new"
              ]
            },
            " global scope, not shared with the original script."
          ]
        }
      ],
      "title": "Script execution timeline"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "The ",
            {
              "element": "literal",
              "content": [
                "setTimeout"
              ]
            },
            " function is similar to ",
            {
              "element": "literal",
              "content": [
                "requestAnimationFrame"
              ]
            },
            ". It schedules another function to be called later. But instead of calling the function at the next redraw, it waits for a given amount of milliseconds. This page turns from blue to yellow after two seconds:"
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": []
        },
        {
          "element": "p",
          "content": [
            "Sometimes you need to cancel a function you have scheduled. This is done by storing the value returned by ",
            {
              "element": "literal",
              "content": [
                "setTimeout"
              ]
            },
            " and calling ",
            {
              "element": "literal",
              "content": [
                "clearTimeout"
              ]
            },
            " on it."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": []
        },
        {
          "element": "p",
          "content": [
            "The ",
            {
              "element": "literal",
              "content": [
                "cancelAnimationFrame"
              ]
            },
            " function works in the same way as ",
            {
              "element": "literal",
              "content": [
                "clearTimeout"
              ]
            },
            "—calling it on a value returned by ",
            {
              "element": "literal",
              "content": [
                "requestAnimationFrame"
              ]
            },
            " will cancel that frame (assuming it hasn’t already been called)."
          ]
        },
        {
          "element": "p",
          "content": [
            "A similar set of functions, ",
            {
              "element": "literal",
              "content": [
                "setInterval"
              ]
            },
            " and ",
            {
              "element": "literal",
              "content": [
                "clearInterval"
              ]
            },
            " are used to set timers that should repeat every ",
            {
              "element": "em",
              "content": [
                "X"
              ]
            },
            " milliseconds."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": []
        }
      ],
      "title": "Setting timers"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "Some types of events have the potential to fire rapidly, many times in a row (the ",
            {
              "element": "literal",
              "content": [
                "\"mousemove\""
              ]
            },
            " and ",
            {
              "element": "literal",
              "content": [
                "\"scroll\""
              ]
            },
            " events, for example). When handling such events, you must be careful not to do anything too time-consuming or your handler will take up so much time that interaction with the document starts to feel slow and choppy."
          ]
        },
        {
          "element": "p",
          "content": [
            "If you do need to do something nontrivial in such a handler, you can use ",
            {
              "element": "literal",
              "content": [
                "setTimeout"
              ]
            },
            " to make sure you are not doing it too often. This is usually called ",
            {
              "element": "em",
              "content": [
                "debouncing"
              ]
            },
            " the event. There are several slightly different approaches to this."
          ]
        },
        {
          "element": "p",
          "content": [
            "In the first example, we want to do something when the user has typed something, but we don’t want to do it immediately for every key event. When they are typing quickly, we just want to wait until a pause occurs. Instead of immediately performing an action in the event handler, we set a timeout instead. We also clear the previous timeout (if any) so that when events occur close together (closer than our timeout delay), the timeout from the previous event will be canceled."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": []
        },
        {
          "element": "p",
          "content": [
            "Giving an undefined value to ",
            {
              "element": "literal",
              "content": [
                "clearTimeout"
              ]
            },
            " or calling it on a timeout that has already fired has no effect. Thus, we don’t have to be careful about when to call it, and we simply do so for every event."
          ]
        },
        {
          "element": "p",
          "content": [
            "We can use a slightly different pattern if we want to space responses so that they’re separated by at least a certain length of time but want to fire them ",
            {
              "element": "em",
              "content": [
                "during"
              ]
            },
            " a series of events, not just afterward. For example, we might want to respond to ",
            {
              "element": "literal",
              "content": [
                "\"mousemove\""
              ]
            },
            " events by showing the current coordinates of the mouse, but only every 250 milliseconds."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": []
        }
      ],
      "title": "Debouncing"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "Event handlers make it possible to detect and react to events we have no direct control over. The ",
            {
              "element": "literal",
              "content": [
                "addEventListener"
              ]
            },
            " method is used to register such a handler."
          ]
        },
        {
          "element": "p",
          "content": [
            "Each event has a type (",
            {
              "element": "literal",
              "content": [
                "\"keydown\""
              ]
            },
            ", ",
            {
              "element": "literal",
              "content": [
                "\"focus\""
              ]
            },
            ", and so on) that identifies it. Most events are called on a specific DOM element and then ",
            {
              "element": "em",
              "content": [
                "propagate"
              ]
            },
            " to that element’s ancestors, allowing handlers associated with those elements to handle them."
          ]
        },
        {
          "element": "p",
          "content": [
            "When an event handler is called, it is passed an event object with additional information about the event. This object also has methods that allow us to stop further propagation (",
            {
              "element": "literal",
              "content": [
                "stopPropagation"
              ]
            },
            ") and prevent the browser’s default handling of the event (",
            {
              "element": "literal",
              "content": [
                "preventDefault"
              ]
            },
            ")."
          ]
        },
        {
          "element": "p",
          "content": [
            "Pressing a key fires ",
            {
              "element": "literal",
              "content": [
                "\"keydown\""
              ]
            },
            ", ",
            {
              "element": "literal",
              "content": [
                "\"keypress\""
              ]
            },
            ", and ",
            {
              "element": "literal",
              "content": [
                "\"keyup\""
              ]
            },
            " events. Pressing a mouse button fires ",
            {
              "element": "literal",
              "content": [
                "\"mousedown\""
              ]
            },
            ", ",
            {
              "element": "literal",
              "content": [
                "\"mouseup\""
              ]
            },
            ", and ",
            {
              "element": "literal",
              "content": [
                "\"click\""
              ]
            },
            " events. Moving the mouse fires ",
            {
              "element": "literal",
              "content": [
                "\"mousemove\""
              ]
            },
            " and possibly ",
            {
              "element": "literal",
              "content": [
                "\"mouseenter\""
              ]
            },
            " and ",
            {
              "element": "literal",
              "content": [
                "\"mouseout\""
              ]
            },
            " events."
          ]
        },
        {
          "element": "p",
          "content": [
            "Scrolling can be detected with the ",
            {
              "element": "literal",
              "content": [
                "\"scroll\""
              ]
            },
            " event, and focus changes can be detected with the ",
            {
              "element": "literal",
              "content": [
                "\"focus\""
              ]
            },
            " and ",
            {
              "element": "literal",
              "content": [
                "\"blur\""
              ]
            },
            " events. When the document finishes loading, a ",
            {
              "element": "literal",
              "content": [
                "\"load\""
              ]
            },
            " event fires on the window."
          ]
        },
        {
          "element": "p",
          "content": [
            "Only one piece of JavaScript program can run at a time. Thus, event handlers and other scheduled scripts have to wait until other scripts finish before they get their turn."
          ]
        }
      ],
      "title": "Summary"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "section",
          "content": [
            {
              "element": "p",
              "content": [
                "Between 1928 and 2013, Turkish law forbade the use of the letters ",
                {
                  "element": "em",
                  "content": [
                    "Q"
                  ]
                },
                ", ",
                {
                  "element": "em",
                  "content": [
                    "W"
                  ]
                },
                ", and ",
                {
                  "element": "em",
                  "content": [
                    "X"
                  ]
                },
                " in official documents. This was part of a wider initiative to stifle Kurdish culture—those letters occur in the language used by Kurdish people but not in Istanbul Turkish."
              ]
            },
            {
              "element": "p",
              "content": [
                "As an exercise in doing ridiculous things with technology, I’m asking you to program a text field (an ",
                {
                  "element": "literal",
                  "content": [
                    "<",
                    "input type=\"text\"",
                    ">"
                  ]
                },
                " tag) that these letters cannot be typed into."
              ]
            },
            {
              "element": "p",
              "content": [
                "(Do not worry about copy and paste and other such loopholes.)"
              ]
            },
            {
              "element": "p",
              "content": [
                "The solution to this exercise involves preventing the default behavior of key events. You can handle either ",
                {
                  "element": "literal",
                  "content": [
                    "\"keypress\""
                  ]
                },
                " or ",
                {
                  "element": "literal",
                  "content": [
                    "\"keydown\""
                  ]
                },
                ". If either of them has ",
                {
                  "element": "literal",
                  "content": [
                    "preventDefault"
                  ]
                },
                " called on it, the letter will not appear."
              ]
            },
            {
              "element": "p",
              "content": [
                "Identifying the letter typed requires looking at the ",
                {
                  "element": "literal",
                  "content": [
                    "keyCode"
                  ]
                },
                " or ",
                {
                  "element": "literal",
                  "content": [
                    "charCode"
                  ]
                },
                " property and comparing that with the codes for the letters you want to filter. In ",
                {
                  "element": "literal",
                  "content": [
                    "\"keydown\""
                  ]
                },
                ", you do not have to worry about lowercase and uppercase letters, since it identifies only the key pressed. If you decide to handle ",
                {
                  "element": "literal",
                  "content": [
                    "\"keypress\""
                  ]
                },
                " instead, which identifies the actual character typed, you have to make sure you test for both cases. One way to do that would be this:"
              ]
            },
            {
              "element": "pre",
              "content": "/[qwx]/i.test(String.fromCharCode(event.charCode))"
            }
          ],
          "title": "Censored keyboard"
        },
        {
          "element": "section",
          "content": [
            {
              "element": "p",
              "content": [
                "In JavaScript’s early days, which was the high time of gaudy home pages with lots of animated images, people came up with some truly inspiring ways to use the language."
              ]
            },
            {
              "element": "p",
              "content": [
                "One of these was the “mouse trail”—a series of images that would follow the mouse pointer as you moved it across the page."
              ]
            },
            {
              "element": "p",
              "content": [
                "In this exercise, I want you to implement a mouse trail. Use absolutely positioned ",
                {
                  "element": "literal",
                  "content": [
                    "<",
                    "div",
                    ">"
                  ]
                },
                " elements with a fixed size and background color (refer to the ",
                {
                  "element": "reference",
                  "content": "code"
                },
                " in the “Mouse Clicks” section for an example). Create a bunch of such elements and, when the mouse moves, display them in the wake of the mouse pointer."
              ]
            },
            {
              "element": "p",
              "content": [
                "There are various possible approaches here. You can make your solution as simple or as complex as you want. A simple solution to start with is to keep a fixed number of trail elements and cycle through them, moving the next one to the mouse’s current position every time a ",
                {
                  "element": "literal",
                  "content": [
                    "\"mousemove\""
                  ]
                },
                " event occurs."
              ]
            },
            {
              "element": "p",
              "content": [
                "Creating the elements is best done in a loop. Append them to the document to make them show up. To be able to access them later to change their position, store the trail elements in an array."
              ]
            },
            {
              "element": "p",
              "content": [
                " Cycling through them can be done by keeping a counter variable and adding 1 to it every time the ",
                {
                  "element": "literal",
                  "content": [
                    "\"mousemove\""
                  ]
                },
                " event fires. The remainder operator (",
                {
                  "element": "literal",
                  "content": [
                    "% 10"
                  ]
                },
                ") can then be used to get a valid array index to pick the element you want to position during a given event."
              ]
            },
            {
              "element": "p",
              "content": [
                "Another interesting effect can be achieved by modeling a simple physics system. Use the ",
                {
                  "element": "literal",
                  "content": [
                    "\"mousemove\""
                  ]
                },
                " event only to update a pair of variables that track the mouse position. Then use ",
                {
                  "element": "literal",
                  "content": [
                    "requestAnimationFrame"
                  ]
                },
                " to simulate the trailing elements being attracted to the position of the mouse pointer. At every animation step, update their position based on their position relative to the pointer (and, optionally, a speed that is stored for each element). Figuring out a good way to do this is up to you."
              ]
            }
          ],
          "title": "Mouse trail"
        },
        {
          "element": "section",
          "content": [
            {
              "element": "p",
              "content": [
                "A tabbed interface is a common design pattern. It allows you to select an interface panel by choosing from a number of tabs “sticking out” above an element."
              ]
            },
            {
              "element": "p",
              "content": [
                "In this exercise you’ll implement a simple tabbed interface. Write a function, ",
                {
                  "element": "literal",
                  "content": [
                    "asTabs"
                  ]
                },
                ", that takes a DOM node and creates a tabbed interface showing the child elements of that node. It should insert a list of ",
                {
                  "element": "literal",
                  "content": [
                    "<",
                    "button",
                    ">"
                  ]
                },
                " elements at the top of the node, one for each child element, containing text retrieved from the ",
                {
                  "element": "literal",
                  "content": [
                    "data-tabname"
                  ]
                },
                " attribute of the child. All but one of the original children should be hidden (given a ",
                {
                  "element": "literal",
                  "content": [
                    "display"
                  ]
                },
                " style of ",
                {
                  "element": "literal",
                  "content": [
                    "none"
                  ]
                },
                "), and the currently visible node can be selected by clicking the buttons."
              ]
            },
            {
              "element": "p",
              "content": [
                "When it works, extend it to also style the currently active button differently."
              ]
            },
            {
              "element": "p",
              "content": [
                "One pitfall you’ll probably run into is that you can’t directly use the node’s ",
                {
                  "element": "literal",
                  "content": [
                    "childNodes"
                  ]
                },
                " property as a collection of tab nodes. For one thing, when you add the buttons, they will also become child nodes and end up in this object because it is live. For another, the text nodes created for the whitespace between the nodes are also in there and should not get their own tabs."
              ]
            },
            {
              "element": "p",
              "content": [
                "To work around this, start by building up a real array of all the children in the wrapper that have a ",
                {
                  "element": "literal",
                  "content": [
                    "nodeType"
                  ]
                },
                " of 1."
              ]
            },
            {
              "element": "p",
              "content": [
                "When registering event handlers on the buttons, the handler functions will need to know which tab element is associated with the button. If they are created in a normal loop, you can access the loop index variable from inside the function, but it won’t give you the correct number because that variable will have been further changed by the loop."
              ]
            },
            {
              "element": "p",
              "content": [
                "A simple workaround is to use the ",
                {
                  "element": "literal",
                  "content": [
                    "forEach"
                  ]
                },
                " method and create the handler functions from inside the function passed to ",
                {
                  "element": "literal",
                  "content": [
                    "forEach"
                  ]
                },
                ". The loop index, which is passed as a second argument to that function, will be a normal local variable there and won’t be overwritten by further iterations."
              ]
            }
          ],
          "title": "Tabs"
        }
      ],
      "title": "Exercises"
    }
  ],
  "title": "Handling Events"
}
