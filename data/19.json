{
  "content": [
    {
      "element": "blockquote",
      "attribution": "Joan Miro",
      "content": [
        {
          "element": "p",
          "content": [
            "I look at the many colors before me. I look at my blank canvas. Then, I try to apply colors like words that shape poems, like notes that shape music."
          ]
        }
      ]
    },
    {
      "element": "p",
      "content": [
        "The material from the previous chapters gives you all the elements you need to build a simple web application. In this chapter, we will do just that."
      ]
    },
    {
      "element": "p",
      "content": [
        "Our application will be a web-based drawing program, along the lines of Microsoft Paint. You can use it to open image files, scribble on them with your mouse, and save them. This is what it will look like:"
      ]
    },
    {
      "element": "img",
      "src": "img/paint.png"
    },
    {
      "element": "p",
      "content": [
        "Painting on a computer is great. You don’t need to worry about materials, skill, or talent. You just start smearing."
      ]
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "The interface for the paint program shows a big ",
            {
              "element": "literal",
              "content": [
                "<canvas>"
              ]
            },
            " element on top, with a number of form fields below it. The user draws on the picture by selecting a tool from a ",
            {
              "element": "literal",
              "content": [
                "<select>"
              ]
            },
            " field and then clicking or dragging across the canvas. There are tools for drawing lines, erasing parts of the picture, adding text, and so on."
          ]
        },
        {
          "element": "p",
          "content": [
            "Clicking the canvas will hand off the ",
            {
              "element": "literal",
              "content": [
                "\"mousedown\""
              ]
            },
            " event to the currently selected tool, which can handle it in whichever way it chooses. The line drawing tool, for example, will listen for ",
            {
              "element": "literal",
              "content": [
                "\"mousemove\""
              ]
            },
            " events until the mouse button is released and draw lines along the mouse’s path using the current color and brush size."
          ]
        },
        {
          "element": "p",
          "content": [
            "Color and brush size are selected with additional form fields. These are hooked up to update the canvas drawing context’s ",
            {
              "element": "literal",
              "content": [
                "fillStyle"
              ]
            },
            ", ",
            {
              "element": "literal",
              "content": [
                "strokeStyle"
              ]
            },
            ", and ",
            {
              "element": "literal",
              "content": [
                "lineWidth"
              ]
            },
            " whenever they are changed."
          ]
        },
        {
          "element": "p",
          "content": [
            "You can load an image into the program in two ways. The first uses a file field, where the user can select a file on their own file system. The second asks for a URL and will fetch an image from the Web."
          ]
        },
        {
          "element": "p",
          "content": [
            "Images are saved in a somewhat atypical way. The save link at the right side points at the current image. It can be followed, shared, or saved. I will explain how this is achieved in a moment."
          ]
        }
      ],
      "title": "Implementation"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "Our program’s interface is built from more than 30 DOM elements. We need to construct these somehow."
          ]
        },
        {
          "element": "p",
          "content": [
            "HTML is the most obvious format for defining complex DOM structures. But separating the program into a piece of HTML and a script is made difficult by the fact that many of the DOM elements need event handlers or have to be touched by the script in some other way. Thus, our script would have to make lots of ",
            {
              "element": "literal",
              "content": [
                "querySelector"
              ]
            },
            " (or similar) calls in order to find the DOM elements that it needs to act on."
          ]
        },
        {
          "element": "p",
          "content": [
            "It would be nice if the DOM structure for each part of our interface is defined close to the JavaScript code that drives it. Thus, I’ve chosen to do all creation of DOM nodes in JavaScript. As we saw in ",
            {
              "element": "reference",
              "content": [
                "Chapter 13"
              ]
            },
            ", the built-in interface for building up a DOM structure is horrendously verbose. If we are going to do a lot of DOM construction, we need a helper function."
          ]
        },
        {
          "element": "p",
          "content": [
            "This helper function is an extended version of the ",
            {
              "element": "literal",
              "content": [
                "elt"
              ]
            },
            " function from ",
            {
              "element": "reference",
              "content": [
                "Chapter 13"
              ]
            },
            ". It creates an element with the given name and attributes and appends all further arguments it gets as child nodes, automatically converting strings to text nodes."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "function elt(name, attributes) {\n  var node = document.createElement(name);\n  if (attributes) {\n    for (var attr in attributes)\n      if (attributes.hasOwnProperty(attr))\n        node.setAttribute(attr, attributes[attr]);\n  }\n  for (var i = 2; i < arguments.length; i++) {\n    var child = arguments[i];\n    if (typeof child == \"string\")\n      child = document.createTextNode(child);\n    node.appendChild(child);\n  }\n  return node;\n}"
        },
        {
          "element": "p",
          "content": [
            "This allows us to create elements easily, without making our source code as long and dull as a corporate end-user agreement."
          ]
        }
      ],
      "title": "Building the DOM"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "The core of our program is the ",
            {
              "element": "literal",
              "content": [
                "createPaint"
              ]
            },
            " function, which appends the paint interface to the DOM element it is given as an argument. Because we want to build our program piece by piece, we define an object called ",
            {
              "element": "literal",
              "content": [
                "controls"
              ]
            },
            ", which will hold functions to initialize the various controls below the image."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "var controls = Object.create(null);\n\nfunction createPaint(parent) {\n  var canvas = elt(\"canvas\", {width: 500, height: 300});\n  var cx = canvas.getContext(\"2d\");\n  var toolbar = elt(\"div\", {class: \"toolbar\"});\n  for (var name in controls)\n    toolbar.appendChild(controls[name](cx));\n\n  var panel = elt(\"div\", {class: \"picturepanel\"}, canvas);\n  parent.appendChild(elt(\"div\", null, panel, toolbar));\n}"
        },
        {
          "element": "p",
          "content": [
            "Each control has access to the canvas drawing context and, through that context’s ",
            {
              "element": "literal",
              "content": [
                "canvas"
              ]
            },
            " property, to the ",
            {
              "element": "literal",
              "content": [
                "<canvas>"
              ]
            },
            " element. Most of the program’s state lives in this canvas—it contains the current picture as well as the selected color (in its ",
            {
              "element": "literal",
              "content": [
                "fillStyle"
              ]
            },
            " property) and brush size (in its ",
            {
              "element": "literal",
              "content": [
                "lineWidth"
              ]
            },
            " property)."
          ]
        },
        {
          "element": "p",
          "content": [
            "We wrap the canvas and the controls in ",
            {
              "element": "literal",
              "content": [
                "<div>"
              ]
            },
            " elements with classes so we can add some styling, such as a gray border around the picture."
          ]
        }
      ],
      "title": "The foundation"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "The first control we add is the ",
            {
              "element": "literal",
              "content": [
                "<select>"
              ]
            },
            " element that allows the user to pick a drawing tool. As with ",
            {
              "element": "literal",
              "content": [
                "controls"
              ]
            },
            ", we will use an object to collect the various tools so that we do not have to hard-code them all in one place and can add more tools later. This object associates the names of the tools with the function that should be called when they are selected and the canvas is clicked."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "var tools = Object.create(null);\n\ncontrols.tool = function(cx) {\n  var select = elt(\"select\");\n  for (var name in tools)\n    select.appendChild(elt(\"option\", null, name));\n\n  cx.canvas.addEventListener(\"mousedown\", function(event) {\n    if (event.which == 1) {\n      tools[select.value](event, cx);\n      event.preventDefault();\n    }\n  });\n\n  return elt(\"span\", null, \"Tool: \", select);\n};"
        },
        {
          "element": "p",
          "content": [
            "The tool field is populated with ",
            {
              "element": "literal",
              "content": [
                "<option>"
              ]
            },
            " elements for all tools that have been defined, and a ",
            {
              "element": "literal",
              "content": [
                "\"mousedown\""
              ]
            },
            " handler on the canvas element takes care of calling the function for the current tool, passing it both the event object and the drawing context as arguments. It also calls ",
            {
              "element": "literal",
              "content": [
                "preventDefault"
              ]
            },
            " so that holding the mouse button and dragging does not cause the browser to select parts of the page."
          ]
        },
        {
          "element": "p",
          "content": [
            "The most basic tool is the line tool, which allows the user to draw lines with the mouse. To put the line ends in the right place, we need to be able to find the canvas-relative coordinates that a given mouse event corresponds to. The ",
            {
              "element": "literal",
              "content": [
                "getBoundingClientRect"
              ]
            },
            " method, briefly mentioned in ",
            {
              "element": "reference",
              "content": [
                "Chapter 13"
              ]
            },
            ", can help us here. It tells us where an element is shown, relative to the top-left corner of the screen. The ",
            {
              "element": "literal",
              "content": [
                "clientX"
              ]
            },
            " and ",
            {
              "element": "literal",
              "content": [
                "clientY"
              ]
            },
            " properties on mouse events are also relative to this corner, so we can subtract the top-left corner of the canvas from them to get a position relative to that corner."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "function relativePos(event, element) {\n  var rect = element.getBoundingClientRect();\n  return {x: Math.floor(event.clientX - rect.left),\n          y: Math.floor(event.clientY - rect.top)};\n}"
        },
        {
          "element": "p",
          "content": [
            "Several of the drawing tools need to listen for ",
            {
              "element": "literal",
              "content": [
                "\"mousemove\""
              ]
            },
            " events as long as the mouse button is held down. The ",
            {
              "element": "literal",
              "content": [
                "trackDrag"
              ]
            },
            " function takes care of the event registration and unregistration for such situations."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "function trackDrag(onMove, onEnd) {\n  function end(event) {\n    removeEventListener(\"mousemove\", onMove);\n    removeEventListener(\"mouseup\", end);\n    if (onEnd)\n      onEnd(event);\n  }\n  addEventListener(\"mousemove\", onMove);\n  addEventListener(\"mouseup\", end);\n}"
        },
        {
          "element": "p",
          "content": [
            "This function takes two arguments. One is a function to call for each ",
            {
              "element": "literal",
              "content": [
                "\"mousemove\""
              ]
            },
            " event, and the other is a function to call when the mouse button is released. Either argument can be omitted when it is not needed."
          ]
        },
        {
          "element": "p",
          "content": [
            "The line tool uses these two helpers to do the actual drawing."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "tools.Line = function(event, cx, onEnd) {\n  cx.lineCap = \"round\";\n\n  var pos = relativePos(event, cx.canvas);\n  trackDrag(function(event) {\n    cx.beginPath();\n    cx.moveTo(pos.x, pos.y);\n    pos = relativePos(event, cx.canvas);\n    cx.lineTo(pos.x, pos.y);\n    cx.stroke();\n  }, onEnd);\n};"
        },
        {
          "element": "p",
          "content": [
            "The function starts by setting the drawing context’s ",
            {
              "element": "literal",
              "content": [
                "lineCap"
              ]
            },
            " property to ",
            {
              "element": "literal",
              "content": [
                "\"round\""
              ]
            },
            ", which causes both ends of a stroked path to be round rather than the default square form. This is a trick to make sure that multiple separate lines, drawn in response to separate events, look like a single, coherent line. With bigger line widths, you will see gaps at corners if you use the default flat line caps."
          ]
        },
        {
          "element": "p",
          "content": [
            "Then, for every ",
            {
              "element": "literal",
              "content": [
                "\"mousemove\""
              ]
            },
            " event that occurs as long as the mouse button is down, a simple line segment is drawn between the mouse’s old and new position, using whatever ",
            {
              "element": "literal",
              "content": [
                "strokeStyle"
              ]
            },
            " and ",
            {
              "element": "literal",
              "content": [
                "lineWidth"
              ]
            },
            " happen to be currently set."
          ]
        },
        {
          "element": "p",
          "content": [
            "The ",
            {
              "element": "literal",
              "content": [
                "onEnd"
              ]
            },
            " argument to ",
            {
              "element": "literal",
              "content": [
                "tools.Line"
              ]
            },
            " is simply passed through to ",
            {
              "element": "literal",
              "content": [
                "trackDrag"
              ]
            },
            ". The normal way to run tools won’t pass a third argument, so when using the line tool, that argument will hold ",
            {
              "element": "literal",
              "content": [
                "undefined"
              ]
            },
            ", and nothing happens at the end of the mouse drag. The argument is there to allow us to implement the erase tool on top of the line tool with very little additional code."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "tools.Erase = function(event, cx) {\n  cx.globalCompositeOperation = \"destination-out\";\n  tools.Line(event, cx, function() {\n    cx.globalCompositeOperation = \"source-over\";\n  });\n};"
        },
        {
          "element": "p",
          "content": [
            "The ",
            {
              "element": "literal",
              "content": [
                "globalCompositeOperation"
              ]
            },
            " property influences the way drawing operations on a canvas change the color of the pixels they touch. By default, the property’s value is ",
            {
              "element": "literal",
              "content": [
                "\"source-over\""
              ]
            },
            ", which means that the drawn color is overlaid on the existing color at that spot. If the color is opaque, it will simply replace the old color, but if it is partially transparent, the two will be mixed."
          ]
        },
        {
          "element": "p",
          "content": [
            "The erase tool sets ",
            {
              "element": "literal",
              "content": [
                "globalCompositeOperation"
              ]
            },
            " to ",
            {
              "element": "literal",
              "content": [
                "\"destination-out\""
              ]
            },
            ", which has the effect of erasing the pixels we touch, making them transparent again."
          ]
        },
        {
          "element": "p",
          "content": [
            "That gives us two tools in our paint program. We can draw black lines a single pixel wide (the default ",
            {
              "element": "literal",
              "content": [
                "strokeStyle"
              ]
            },
            " and ",
            {
              "element": "literal",
              "content": [
                "lineWidth"
              ]
            },
            " for a canvas) and erase them again. It is a working, albeit rather limited, paint program."
          ]
        }
      ],
      "title": "Tool selection"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "Assuming that users will want to draw in colors other than black and use different brush sizes, let’s add controls for those two settings."
          ]
        },
        {
          "element": "p",
          "content": [
            "In ",
            {
              "element": "reference",
              "content": [
                "Chapter 18"
              ]
            },
            ", I discussed a number of different form fields. Color fields were not among those. Traditionally, browsers don’t have built-in support for color pickers, but in the past few years, a number of new form field types have been standardized. One of those is ",
            {
              "element": "literal",
              "content": [
                "<input type=\"color\">"
              ]
            },
            ". Others include ",
            {
              "element": "literal",
              "content": [
                "\"date\""
              ]
            },
            ", ",
            {
              "element": "literal",
              "content": [
                "\"email\""
              ]
            },
            ", ",
            {
              "element": "literal",
              "content": [
                "\"url\""
              ]
            },
            ", and ",
            {
              "element": "literal",
              "content": [
                "\"number\""
              ]
            },
            ". Not all browsers support them yet—at the time of writing, no version of Internet Explorer supports color fields. The default type of an ",
            {
              "element": "literal",
              "content": [
                "<input>"
              ]
            },
            " tag is ",
            {
              "element": "literal",
              "content": [
                "\"text\""
              ]
            },
            ", and when an unsupported type is used, browsers will treat it as a text field. This means that Internet Explorer users running our paint program will have to type in the name of the color they want, rather than select it from a convenient widget."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "controls.color = function(cx) {\n  var input = elt(\"input\", {type: \"color\"});\n  input.addEventListener(\"change\", function() {\n    cx.fillStyle = input.value;\n    cx.strokeStyle = input.value;\n  });\n  return elt(\"span\", null, \"Color: \", input);\n};"
        },
        {
          "element": "p",
          "content": [
            "Whenever the value of the color field changes, the drawing context’s ",
            {
              "element": "literal",
              "content": [
                "fillStyle"
              ]
            },
            " and ",
            {
              "element": "literal",
              "content": [
                "strokeStyle"
              ]
            },
            " are updated to hold the new value."
          ]
        },
        {
          "element": "p",
          "content": [
            "The field for configuring the brush size works similarly."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "controls.brushSize = function(cx) {\n  var select = elt(\"select\");\n  var sizes = [1, 2, 3, 5, 8, 12, 25, 35, 50, 75, 100];\n  sizes.forEach(function(size) {\n    select.appendChild(elt(\"option\", {value: size},\n                           size + \" pixels\"));\n  });\n  select.addEventListener(\"change\", function() {\n    cx.lineWidth = select.value;\n  });\n  return elt(\"span\", null, \"Brush size: \", select);\n};"
        },
        {
          "element": "p",
          "content": [
            "The code generates options from an array of brush sizes, and again ensures that the canvas’ ",
            {
              "element": "literal",
              "content": [
                "lineWidth"
              ]
            },
            " is updated when a brush size is chosen."
          ]
        }
      ],
      "title": "Color and brush size"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "To explain the implementation of the save link, I must first tell you about ",
            {
              "element": "em",
              "content": [
                "data URLs"
              ]
            },
            ". A data URL is a URL with ",
            {
              "element": "em",
              "content": [
                "data:"
              ]
            },
            " as its protocol. Unlike regular ",
            {
              "element": "em",
              "content": [
                "http:"
              ]
            },
            " and ",
            {
              "element": "em",
              "content": [
                "https:"
              ]
            },
            " URLs, data URLs don’t point at a resource but rather contain the entire resource in them. This is a data URL containing a simple HTML document:"
          ]
        },
        {
          "element": "pre",
          "content": "data:text/html,<h1 style=\"color:red\">Hello!</h1>"
        },
        {
          "element": "p",
          "content": [
            "Data URLs are useful for various tasks, such as including small images directly in a style sheet file. They also allow us to link to files that we created on the client side, in the browser, without first moving them to some server."
          ]
        },
        {
          "element": "p",
          "content": [
            "Canvas elements have a convenient method, called ",
            {
              "element": "literal",
              "content": [
                "toDataURL"
              ]
            },
            ", which will return a data URL that contains the picture on the canvas as an image file. We don’t want to update our save link every time the picture is changed, however. For big pictures, that involves moving quite a lot of data into a link and would be noticeably slow. Instead, we rig the link to update its ",
            {
              "element": "literal",
              "content": [
                "href"
              ]
            },
            " attribute whenever it is focused with the keyboard or the mouse is moved over it."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "controls.save = function(cx) {\n  var link = elt(\"a\", {href: \"/\"}, \"Save\");\n  function update() {\n    try {\n      link.href = cx.canvas.toDataURL();\n    } catch (e) {\n      if (e instanceof SecurityError)\n        link.href = \"javascript:alert(\" +\n          JSON.stringify(\"Can't save: \" + e.toString()) + \")\";\n      else\n        throw e;\n    }\n  }\n  link.addEventListener(\"mouseover\", update);\n  link.addEventListener(\"focus\", update);\n  return link;\n};"
        },
        {
          "element": "p",
          "content": [
            "Thus, the link just quietly sits there, pointing at the wrong thing, but when the user approaches it, it magically updates itself to point at the current picture."
          ]
        },
        {
          "element": "p",
          "content": [
            "If you load a big image, some browsers will choke on the giant data URLs that this produces. For small pictures, this approach works without problem."
          ]
        },
        {
          "element": "p",
          "content": [
            "But here we once again run into the subtleties of browser sandboxing. When an image is loaded from a URL on another domain, if the server’s response doesn’t include a header that tells the browser the resource may be used from other domains (see ",
            {
              "element": "reference",
              "content": [
                "Chapter 17"
              ]
            },
            "), then the canvas will contain information that the ",
            {
              "element": "em",
              "content": [
                "user"
              ]
            },
            " may look at but that the ",
            {
              "element": "em",
              "content": [
                "script"
              ]
            },
            " may not."
          ]
        },
        {
          "element": "p",
          "content": [
            "We may have requested a picture that contains private information (for example, a graph showing the user’s bank account balance) using the user’s session. If scripts could get information out of that picture, they could snoop on the user in undesirable ways."
          ]
        },
        {
          "element": "p",
          "content": [
            "To prevent these kinds of information leaks, browsers will mark a canvas as ",
            {
              "element": "em",
              "content": [
                "tainted"
              ]
            },
            " when an image that the script may not see is drawn onto it. Pixel data, including data URLs, may not be extracted from a tainted canvas. You can write to it, but you can no longer read it."
          ]
        },
        {
          "element": "p",
          "content": [
            "This is why we need the ",
            {
              "element": "literal",
              "content": [
                "try/catch"
              ]
            },
            " statement in the ",
            {
              "element": "literal",
              "content": [
                "update"
              ]
            },
            " function for the save link. When the canvas has become tainted, calling ",
            {
              "element": "literal",
              "content": [
                "toDataURL"
              ]
            },
            " will raise an exception that is an instance of ",
            {
              "element": "literal",
              "content": [
                "SecurityError"
              ]
            },
            ". When that happens, we set the link to point at yet another kind of URL, using the ",
            {
              "element": "em",
              "content": [
                "javascript:"
              ]
            },
            " protocol. Such links simply execute the script given after the colon when they are followed so that the link will show an ",
            {
              "element": "literal",
              "content": [
                "alert"
              ]
            },
            " window informing the user of the problem when it is clicked."
          ]
        }
      ],
      "title": "Saving"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "The final two controls are used to load images from local files and from URLs. We’ll need the following helper function, which tries to load an image file from a URL and replace the contents of the canvas with it:"
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "function loadImageURL(cx, url) {\n  var image = document.createElement(\"img\");\n  image.addEventListener(\"load\", function() {\n    var color = cx.fillStyle, size = cx.lineWidth;\n    cx.canvas.width = image.width;\n    cx.canvas.height = image.height;\n    cx.drawImage(image, 0, 0);\n    cx.fillStyle = color;\n    cx.strokeStyle = color;\n    cx.lineWidth = size;\n  });\n  image.src = url;\n}"
        },
        {
          "element": "p",
          "content": [
            "We want to change the size of the canvas to precisely fit the image. For some reason, changing the size of a canvas will cause its drawing context to forget configuration properties such as ",
            {
              "element": "literal",
              "content": [
                "fillStyle"
              ]
            },
            " and ",
            {
              "element": "literal",
              "content": [
                "lineWidth"
              ]
            },
            ", so the function saves those and restores them after it has updated the canvas size."
          ]
        },
        {
          "element": "p",
          "content": [
            "The control for loading a local file uses the ",
            {
              "element": "literal",
              "content": [
                "FileReader"
              ]
            },
            " technique from ",
            {
              "element": "reference",
              "content": [
                "Chapter 18"
              ]
            },
            ". Apart from the ",
            {
              "element": "literal",
              "content": [
                "readAsText"
              ]
            },
            " method we used there, such reader objects also have a method called ",
            {
              "element": "literal",
              "content": [
                "readAsDataURL"
              ]
            },
            ", which is exactly what we need here. We load the file that the user chose as a data URL and pass it to ",
            {
              "element": "literal",
              "content": [
                "loadImageURL"
              ]
            },
            " to put it into the canvas."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "controls.openFile = function(cx) {\n  var input = elt(\"input\", {type: \"file\"});\n  input.addEventListener(\"change\", function() {\n    if (input.files.length == 0) return;\n    var reader = new FileReader();\n    reader.addEventListener(\"load\", function() {\n      loadImageURL(cx, reader.result);\n    });\n    reader.readAsDataURL(input.files[0]);\n  });\n  return elt(\"div\", null, \"Open file: \", input);\n};"
        },
        {
          "element": "p",
          "content": [
            "Loading a file from a URL is even simpler. But with a text field, it is less clear when the user has finished writing the URL, so we can’t simply listen for ",
            {
              "element": "literal",
              "content": [
                "\"change\""
              ]
            },
            " events. Instead, we will wrap the field in a form and respond when the form is submitted, either because the user pressed Enter or because they clicked the load button."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "controls.openURL = function(cx) {\n  var input = elt(\"input\", {type: \"text\"});\n  var form = elt(\"form\", null,\n                 \"Open URL: \", input,\n                 elt(\"button\", {type: \"submit\"}, \"load\"));\n  form.addEventListener(\"submit\", function(event) {\n    event.preventDefault();\n    loadImageURL(cx, input.value);\n  });\n  return form;\n};"
        },
        {
          "element": "p",
          "content": [
            "We have now defined all the controls that our simple paint program needs, but it could still use a few more tools."
          ]
        }
      ],
      "title": "Loading image files"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "We can easily add a text tool that uses ",
            {
              "element": "literal",
              "content": [
                "prompt"
              ]
            },
            " to ask the user which string it should draw."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "tools.Text = function(event, cx) {\n  var text = prompt(\"Text:\", \"\");\n  if (text) {\n    var pos = relativePos(event, cx.canvas);\n    cx.font = Math.max(7, cx.lineWidth) + \"px sans-serif\";\n    cx.fillText(text, pos.x, pos.y);\n  }\n};"
        },
        {
          "element": "p",
          "content": [
            "You could add extra fields for the font size and the font, but for simplicity’s sake, we always use a sans-serif font and base the font size on the current brush size. The minimum size is 7 pixels because text smaller than that is unreadable."
          ]
        },
        {
          "element": "p",
          "content": [
            "Another indispensable tool for drawing amateurish computer graphics is the spray paint tool. This one draws dots in random locations under the brush as long as the mouse is held down, creating denser or less dense speckling based on how fast or slow the mouse moves."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "tools.Spray = function(event, cx) {\n  var radius = cx.lineWidth / 2;\n  var area = radius * radius * Math.PI;\n  var dotsPerTick = Math.ceil(area / 30);\n\n  var currentPos = relativePos(event, cx.canvas);\n  var spray = setInterval(function() {\n    for (var i = 0; i < dotsPerTick; i++) {\n      var offset = randomPointInRadius(radius);\n      cx.fillRect(currentPos.x + offset.x,\n                  currentPos.y + offset.y, 1, 1);\n    }\n  }, 25);\n  trackDrag(function(event) {\n    currentPos = relativePos(event, cx.canvas);\n  }, function() {\n    clearInterval(spray);\n  });\n};"
        },
        {
          "element": "p",
          "content": [
            "The spray tool uses ",
            {
              "element": "literal",
              "content": [
                "setInterval"
              ]
            },
            " to spit out colored dots every 25 milliseconds as long as the mouse button is held down. The ",
            {
              "element": "literal",
              "content": [
                "trackDrag"
              ]
            },
            " function is used to keep ",
            {
              "element": "literal",
              "content": [
                "currentPos"
              ]
            },
            " pointing at the current mouse position and to turn off the interval when the mouse button is released."
          ]
        },
        {
          "element": "p",
          "content": [
            "To determine how many dots to draw every time the interval fires, the function computes the area of the current brush and divides that by 30. To find a random position under the brush, the ",
            {
              "element": "literal",
              "content": [
                "randomPointInRadius"
              ]
            },
            " function is used."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "function randomPointInRadius(radius) {\n  for (;;) {\n    var x = Math.random() * 2 - 1;\n    var y = Math.random() * 2 - 1;\n    if (x * x + y * y <= 1)\n      return {x: x * radius, y: y * radius};\n  }\n}"
        },
        {
          "element": "p",
          "content": [
            "This function generates points in the square between (-1,-1) and (1,1). Using the Pythagorean theorem, it tests whether the generated point lies within a circle of radius 1. As soon as the function finds such a point, it returns the point multiplied by the ",
            {
              "element": "literal",
              "content": [
                "radius"
              ]
            },
            " argument."
          ]
        },
        {
          "element": "p",
          "content": [
            "The loop is necessary for a uniform distribution of dots. The straightforward way of generating a random point within a circle would be to use a random angle and distance and call ",
            {
              "element": "literal",
              "content": [
                "Math.sin"
              ]
            },
            " and ",
            {
              "element": "literal",
              "content": [
                "Math.cos"
              ]
            },
            " to create the corresponding point. But with that method, the dots are more likely to appear near the center of the circle. There are other ways around that, but they’re more complicated than the previous loop."
          ]
        },
        {
          "element": "p",
          "content": [
            "We now have a functioning paint program. Run the code below to try it."
          ]
        }
      ],
      "title": "Finishing up"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "There is still plenty of room for improvement in this program. Let’s add a few more features as exercises."
          ]
        },
        {
          "element": "section",
          "content": [
            {
              "element": "p",
              "content": [
                "Define a tool called ",
                {
                  "element": "literal",
                  "content": [
                    "Rectangle"
                  ]
                },
                " that fills a rectangle (see the ",
                {
                  "element": "literal",
                  "content": [
                    "fillRect"
                  ]
                },
                " method from ",
                {
                  "element": "reference",
                  "content": [
                    "Chapter 16"
                  ]
                },
                ") with the current color. The rectangle should span from the point where the user pressed the mouse button to the point where they released it. Note that the latter might be above or to the left of the former."
              ]
            },
            {
              "element": "p",
              "content": [
                "Once it works, you’ll notice that it is somewhat jarring to not see the rectangle as you are dragging the mouse to select its size. Can you come up with a way to show some kind of rectangle during the dragging, without actually drawing to the canvas until the mouse button is released?"
              ]
            },
            {
              "element": "p",
              "content": [
                "If nothing comes to mind, think back to the ",
                {
                  "element": "literal",
                  "content": [
                    "position:absolute"
                  ]
                },
                " style discussed in ",
                {
                  "element": "reference",
                  "content": [
                    "Chapter 13"
                  ]
                },
                ", which can be used to overlay a node on the rest of the document. The ",
                {
                  "element": "literal",
                  "content": [
                    "pageX"
                  ]
                },
                " and ",
                {
                  "element": "literal",
                  "content": [
                    "pageY"
                  ]
                },
                " properties of a mouse event can be used to position an element precisely under the mouse, by setting the ",
                {
                  "element": "literal",
                  "content": [
                    "left"
                  ]
                },
                ", ",
                {
                  "element": "literal",
                  "content": [
                    "top"
                  ]
                },
                ", ",
                {
                  "element": "literal",
                  "content": [
                    "width"
                  ]
                },
                ", and ",
                {
                  "element": "literal",
                  "content": [
                    "height"
                  ]
                },
                " styles to the correct pixel values."
              ]
            },
            {
              "element": "hint",
              "content": [
                {
                  "element": "p",
                  "content": [
                    "You can use ",
                    {
                      "element": "literal",
                      "content": [
                        "relativePos"
                      ]
                    },
                    " to find the corner corresponding to the start of the mouse drag. Figuring out where the drag ends can be done with ",
                    {
                      "element": "literal",
                      "content": [
                        "trackDrag"
                      ]
                    },
                    " or by registering your own event handler."
                  ]
                },
                {
                  "element": "p",
                  "content": [
                    "When you have two corners of the rectangle, you must somehow translate these into the arguments that ",
                    {
                      "element": "literal",
                      "content": [
                        "fillRect"
                      ]
                    },
                    " expects: the top-left corner, width, and height of the rectangle. ",
                    {
                      "element": "literal",
                      "content": [
                        "Math.min"
                      ]
                    },
                    " can be used to find the leftmost x-coordinate and topmost y-coordinate. To get the width or height, you can call ",
                    {
                      "element": "literal",
                      "content": [
                        "Math.abs"
                      ]
                    },
                    " (the absolute value) on the difference between two sides."
                  ]
                },
                {
                  "element": "p",
                  "content": [
                    "Showing the rectangle during the mouse drag requires a similar set of numbers but in the context of the whole page rather than relative to the canvas. Consider writing a function ",
                    {
                      "element": "literal",
                      "content": [
                        "findRect"
                      ]
                    },
                    ", which converts two points into an object with ",
                    {
                      "element": "literal",
                      "content": [
                        "top"
                      ]
                    },
                    ", ",
                    {
                      "element": "literal",
                      "content": [
                        "left"
                      ]
                    },
                    ", ",
                    {
                      "element": "literal",
                      "content": [
                        "width"
                      ]
                    },
                    ", and ",
                    {
                      "element": "literal",
                      "content": [
                        "height"
                      ]
                    },
                    " properties so that you don’t have to write the same logic twice."
                  ]
                },
                {
                  "element": "p",
                  "content": [
                    "You can then create a ",
                    {
                      "element": "literal",
                      "content": [
                        "<div>"
                      ]
                    },
                    " node and set its ",
                    {
                      "element": "literal",
                      "content": [
                        "style.position"
                      ]
                    },
                    " to ",
                    {
                      "element": "literal",
                      "content": [
                        "absolute"
                      ]
                    },
                    ". When setting positioning styles, do not forget to append ",
                    {
                      "element": "literal",
                      "content": [
                        "\"px\""
                      ]
                    },
                    " to the numbers. The node must be added to the document (you can append it to ",
                    {
                      "element": "literal",
                      "content": [
                        "document.body"
                      ]
                    },
                    ") and also removed again when the drag ends and the actual rectangle gets drawn onto the canvas."
                  ]
                }
              ]
            }
          ],
          "title": "Rectangles"
        },
        {
          "element": "section",
          "content": [
            {
              "element": "p",
              "content": [
                "Another tool that is commonly found in graphics programs is a color picker, which allows the user to click the picture and selects the color under the mouse pointer. Build this."
              ]
            },
            {
              "element": "p",
              "content": [
                "For this tool, we need a way to access the content of the canvas. The ",
                {
                  "element": "literal",
                  "content": [
                    "toDataURL"
                  ]
                },
                " method more or less did that, but getting pixel information out of such a data URL is hard. Instead, we’ll use the ",
                {
                  "element": "literal",
                  "content": [
                    "getImageData"
                  ]
                },
                " method on the drawing context, which returns a rectangular piece of the image as an object with ",
                {
                  "element": "literal",
                  "content": [
                    "width"
                  ]
                },
                ", ",
                {
                  "element": "literal",
                  "content": [
                    "height"
                  ]
                },
                ", and ",
                {
                  "element": "literal",
                  "content": [
                    "data"
                  ]
                },
                " properties. The ",
                {
                  "element": "literal",
                  "content": [
                    "data"
                  ]
                },
                " property holds an array of numbers from 0 to 255, using four numbers to represent each pixel’s red, green, blue, and alpha (opaqueness) components."
              ]
            },
            {
              "element": "p",
              "content": [
                "This example retrieves the numbers for a single pixel from a canvas once when the canvas is blank (all pixels are transparent black) and once when the pixel has been colored red."
              ]
            },
            {
              "element": "listing",
              "numbered": false,
              "content": "function pixelAt(cx, x, y) {\n  var data = cx.getImageData(x, y, 1, 1);\n  console.log(data.data);\n}\n\nvar canvas = document.createElement(\"canvas\");\nvar cx = canvas.getContext(\"2d\");\npixelAt(cx, 10, 10);\n// → [0, 0, 0, 0]\n\ncx.fillStyle = \"red\";\ncx.fillRect(10, 10, 1, 1);\npixelAt(cx, 10, 10);\n// → [255, 0, 0, 255]"
            },
            {
              "element": "p",
              "content": [
                "The arguments to ",
                {
                  "element": "literal",
                  "content": [
                    "getImageData"
                  ]
                },
                " indicate the starting x- and y-coordinates of the rectangle we want to retrieve, followed by its width and height."
              ]
            },
            {
              "element": "p",
              "content": [
                "Ignore transparency during this exercise and look only at the first three values for a given pixel. Also, do not worry about updating the color field when the user picks a color. Just make sure that the drawing context’s ",
                {
                  "element": "literal",
                  "content": [
                    "fillStyle"
                  ]
                },
                " and ",
                {
                  "element": "literal",
                  "content": [
                    "strokeStyle"
                  ]
                },
                " are set to the color under the mouse cursor."
              ]
            },
            {
              "element": "p",
              "content": [
                "Remember that these properties accept any color that CSS understands, which includes the ",
                {
                  "element": "literal",
                  "content": [
                    "rgb(R, G, B)"
                  ]
                },
                " style you saw in ",
                {
                  "element": "reference",
                  "content": [
                    "Chapter 15"
                  ]
                },
                "."
              ]
            },
            {
              "element": "p",
              "content": [
                "The ",
                {
                  "element": "literal",
                  "content": [
                    "getImageData"
                  ]
                },
                " method is subject to the same restrictions as ",
                {
                  "element": "literal",
                  "content": [
                    "toDataURL"
                  ]
                },
                "—it will raise an error when the canvas contains pixels that originate from another domain. Use a ",
                {
                  "element": "literal",
                  "content": [
                    "try/catch"
                  ]
                },
                " statement to report such errors with an ",
                {
                  "element": "literal",
                  "content": [
                    "alert"
                  ]
                },
                " dialog."
              ]
            },
            {
              "element": "hint",
              "content": [
                {
                  "element": "p",
                  "content": [
                    "You’ll again need to use ",
                    {
                      "element": "literal",
                      "content": [
                        "relativePos"
                      ]
                    },
                    " to find out which pixel was clicked. The ",
                    {
                      "element": "literal",
                      "content": [
                        "pixelAt"
                      ]
                    },
                    " function in the example demonstrates how to get the values for a given pixel. Putting those into an ",
                    {
                      "element": "literal",
                      "content": [
                        "rgb"
                      ]
                    },
                    " string merely requires some string concatenation."
                  ]
                },
                {
                  "element": "p",
                  "content": [
                    "Make sure you verify that the exception you catch is an instance of ",
                    {
                      "element": "literal",
                      "content": [
                        "SecurityError"
                      ]
                    },
                    " so that you don’t accidentally handle the wrong kind of exception."
                  ]
                }
              ]
            }
          ],
          "title": "Color picker"
        },
        {
          "element": "section",
          "content": [
            {
              "element": "p",
              "content": [
                "This is a more advanced exercise than the preceding two, and it will require you to design a nontrivial solution to a tricky problem. Make sure you have plenty of time and patience before starting to work on this exercise, and do not get discouraged by initial failures."
              ]
            },
            {
              "element": "p",
              "content": [
                "A flood fill tool colors the pixel under the mouse and the surrounding pixels of the same color. For the purpose of this exercise, we will consider such a group to include all pixels that can be reached from our starting pixel by moving in single-pixel horizontal and vertical steps (not diagonal), without ever touching a pixel that has a color different from the starting pixel."
              ]
            },
            {
              "element": "p",
              "content": [
                "The following image illustrates the set of pixels colored when the flood fill tool is used at the marked pixel:"
              ]
            },
            {
              "element": "img",
              "src": "img/flood-grid.svg"
            },
            {
              "element": "p",
              "content": [
                "The flood fill does not leak through diagonal gaps and does not touch pixels that are not reachable, even if they have the same color as the target pixel."
              ]
            },
            {
              "element": "p",
              "content": [
                "You will once again need ",
                {
                  "element": "literal",
                  "content": [
                    "getImageData"
                  ]
                },
                " to find out the color for each pixel. It is probably a good idea to fetch the whole image in one go and then pick out pixel data from the resulting array. The pixels are organized in this array in a similar way to the grid elements in ",
                {
                  "element": "reference",
                  "content": [
                    "Chapter 7"
                  ]
                },
                ", one row at a time, except that each pixel is represented by four values. The first value for the pixel at (",
                {
                  "element": "em",
                  "content": [
                    "x"
                  ]
                },
                ",",
                {
                  "element": "em",
                  "content": [
                    "y"
                  ]
                },
                ") is at position (",
                {
                  "element": "em",
                  "content": [
                    "x"
                  ]
                },
                " + ",
                {
                  "element": "em",
                  "content": [
                    "y"
                  ]
                },
                " × width) × 4."
              ]
            },
            {
              "element": "p",
              "content": [
                "Do include the fourth (alpha) value this time since we want to be able to tell the difference between empty and black pixels."
              ]
            },
            {
              "element": "p",
              "content": [
                "Finding all adjacent pixels with the same color requires you to “walk” over the pixel surface, one pixel up, down, left, or right, as long as new same-colored pixels can be found. But you won’t find all pixels in a group on the first walk. Rather, you have to do something similar to the backtracking done by the regular expression matcher, described in ",
                {
                  "element": "reference",
                  "content": [
                    "Chapter 9"
                  ]
                },
                ". Whenever more than one possible direction to proceed is seen, you must store all the directions you do not take immediately and look at them later, when you finish your current walk."
              ]
            },
            {
              "element": "p",
              "content": [
                "In a normal-sized picture, there are a ",
                {
                  "element": "em",
                  "content": [
                    "lot"
                  ]
                },
                " of pixels. Thus, you must take care to do the minimal amount of work required or your program will take a very long time to run. For example, every walk must ignore pixels seen by previous walks so that it does not redo work that has already been done."
              ]
            },
            {
              "element": "p",
              "content": [
                "I recommend calling ",
                {
                  "element": "literal",
                  "content": [
                    "fillRect"
                  ]
                },
                " for individual pixels when a pixel that should be colored is found, and keeping some data structure that tells you about all the pixels that have already been looked at."
              ]
            },
            {
              "element": "hint",
              "content": [
                {
                  "element": "p",
                  "content": [
                    "Given a pair of starting coordinates and the image data for the whole canvas, this approach should work:"
                  ]
                },
                {
                  "element": "ol",
                  "content": [
                    {
                      "element": "item",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            "Create an array to hold information about already colored  coordinates. "
                          ]
                        }
                      ]
                    },
                    {
                      "element": "item",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            "Create a work list array to hold coordinates that must be looked  at. Put the start position in it. "
                          ]
                        }
                      ]
                    },
                    {
                      "element": "item",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            "When the work list is empty, we are done. "
                          ]
                        }
                      ]
                    },
                    {
                      "element": "item",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            "Remove one pair of coordinates from the work list. "
                          ]
                        }
                      ]
                    },
                    {
                      "element": "item",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            "If those coordinates are already in our array of colored pixels, go  back to step 3. "
                          ]
                        }
                      ]
                    },
                    {
                      "element": "item",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            "Color the pixel at the current coordinates and add the  coordinates to the array of colored pixels. "
                          ]
                        }
                      ]
                    },
                    {
                      "element": "item",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            "Add the coordinates of each adjacent pixel whose color is the same  as the starting pixel’s original color to the work list. "
                          ]
                        }
                      ]
                    },
                    {
                      "element": "item",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            "Return to step 3. "
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "element": "p",
                  "content": [
                    "The work list can simply be an array of vector objects. The data structure that tracks colored pixels will be consulted ",
                    {
                      "element": "em",
                      "content": [
                        "very"
                      ]
                    },
                    " often. Searching through the whole thing every time a new pixel is visited will take a lot of time. You could instead create an array that has a value in it for every pixel, using again the x + y × width scheme for associating positions with pixels. When checking whether a pixel has been colored already, you could directly access the field corresponding to the current pixel."
                  ]
                },
                {
                  "element": "p",
                  "content": [
                    "You can compare colors by running over the relevant part of the data array, comparing one field at a time. Or you can “condense” a color to a single number or string and compare those. When doing this, ensure that every color produces a unique value. For example, simply adding the color’s components is not safe since multiple colors will have the same sum."
                  ]
                },
                {
                  "element": "p",
                  "content": [
                    "When enumerating the neighbors of a given point, take care to exclude neighbors that are not inside of the canvas or your program might run off into one direction forever."
                  ]
                }
              ]
            }
          ],
          "title": "Flood fill"
        }
      ],
      "title": "Exercises"
    }
  ],
  "title": "Project: A Paint Program"
}
