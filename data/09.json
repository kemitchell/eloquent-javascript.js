{
  "content": [
    {
      "element": "blockquote",
      "attribution": "Jamie Zawinski",
      "content": [
        {
          "element": "p",
          "content": [
            "Some people, when confronted with a problem, think ‘I know, I’ll use regular expressions.’ Now they have two problems."
          ]
        }
      ]
    },
    {
      "element": "p",
      "content": [
        "Programming tools and techniques survive and spread in a chaotic, evolutionary way. It’s not always the pretty or brilliant ones that win but rather the ones that function well enough within the right niche—for example, by being integrated with another successful piece of technology."
      ]
    },
    {
      "element": "p",
      "content": [
        "In this chapter, I will discuss one such tool, ",
        {
          "element": "em",
          "content": [
            "regular expressions"
          ]
        },
        ". Regular expressions are a way to describe patterns in string data. They form a small, separate language that is part of JavaScript and many other languages and tools."
      ]
    },
    {
      "element": "p",
      "content": [
        "Regular expressions are both terribly awkward and extremely useful. Their syntax is cryptic, and the programming interface JavaScript provides for them is clumsy. But they are a powerful tool for inspecting and processing strings. Properly understanding regular expressions will make you a more effective programmer."
      ]
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "A regular expression is a type of object. It can either be constructed with the ",
            {
              "element": "literal",
              "content": [
                "RegExp"
              ]
            },
            " constructor or written as a literal value by enclosing the pattern in forward slash (",
            {
              "element": "literal",
              "content": [
                "/"
              ]
            },
            ") characters."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "var re1 = new RegExp(\"abc\");\nvar re2 = /abc/;"
        },
        {
          "element": "p",
          "content": [
            "Both of these regular expression objects represent the same pattern: an ",
            {
              "element": "em",
              "content": [
                "a"
              ]
            },
            " character followed by a ",
            {
              "element": "em",
              "content": [
                "b"
              ]
            },
            " followed by a ",
            {
              "element": "em",
              "content": [
                "c"
              ]
            },
            "."
          ]
        },
        {
          "element": "p",
          "content": [
            "When using the ",
            {
              "element": "literal",
              "content": [
                "RegExp"
              ]
            },
            " constructor, the pattern is written as a normal string, so the usual rules apply for backslashes."
          ]
        },
        {
          "element": "p",
          "content": [
            " The second notation, where the pattern appears between slash characters, treats backslashes somewhat differently. First, since a forward slash ends the pattern, we need to put a backslash before any forward slash that we want to be ",
            {
              "element": "em",
              "content": [
                "part"
              ]
            },
            " of the pattern. In addition, backslashes that aren’t part of special character codes (like ",
            {
              "element": "literal",
              "content": [
                "\\n"
              ]
            },
            ") will be ",
            {
              "element": "em",
              "content": [
                "preserved"
              ]
            },
            ", rather than ignored as they are in strings, and change the meaning of the pattern. Some characters, such as question marks and plus signs, have special meanings in regular expressions and must be preceded by a backslash if they are meant to represent the character itself."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "var eighteenPlus = /eighteen\\+/;"
        },
        {
          "element": "p",
          "content": [
            "Knowing precisely what characters to backslash-escape when writing regular expressions requires you to know every character with a special meaning. For the time being, this may not be realistic, so when in doubt, just put a backslash before any character that is not a letter, number, or whitespace."
          ]
        }
      ],
      "title": "Creating a regular expression"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "Regular expression objects have a number of methods. The simplest one is ",
            {
              "element": "literal",
              "content": [
                "test"
              ]
            },
            ". If you pass it a string, it will return a Boolean telling you whether the string contains a match of the pattern in the expression."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "console.log(/abc/.test(\"abcde\"));\n// → true\nconsole.log(/abc/.test(\"abxde\"));\n// → false"
        },
        {
          "element": "p",
          "content": [
            "A regular expression consisting of only nonspecial characters simply represents that sequence of characters. If ",
            {
              "element": "em",
              "content": [
                "abc"
              ]
            },
            " occurs anywhere in the string we are testing against (not just at the start), ",
            {
              "element": "literal",
              "content": [
                "test"
              ]
            },
            " will return ",
            {
              "element": "literal",
              "content": [
                "true"
              ]
            },
            "."
          ]
        }
      ],
      "title": "Testing for matches"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "Finding out whether a string contains ",
            {
              "element": "em",
              "content": [
                "abc"
              ]
            },
            " could just as well be done with a call to ",
            {
              "element": "literal",
              "content": [
                "indexOf"
              ]
            },
            ". Regular expressions allow us to go beyond that and express more complicated patterns."
          ]
        },
        {
          "element": "p",
          "content": [
            "Say we want to match any number. In a regular expression, putting a set of characters between square brackets makes that part of the expression match any of the characters between the brackets."
          ]
        },
        {
          "element": "p",
          "content": [
            "Both of the following expressions match all strings that contain a digit:"
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "console.log(/[0123456789]/.test(\"in 1992\"));\n// → true\nconsole.log(/[0-9]/.test(\"in 1992\"));\n// → true"
        },
        {
          "element": "p",
          "content": [
            "Within square brackets, a dash (",
            {
              "element": "literal",
              "content": [
                "-"
              ]
            },
            ") between two characters can be used to indicate a range of characters, where the ordering is determined by the character’s Unicode number. Characters 0 to 9 sit right next to each other in this ordering (codes 48 to 57), so ",
            {
              "element": "literal",
              "content": [
                "[0-9]"
              ]
            },
            " covers all of them and matches any digit."
          ]
        },
        {
          "element": "p",
          "content": [
            "There are a number of common character groups that have their own built-in shortcuts. Digits are one of them: ",
            {
              "element": "literal",
              "content": [
                "\\d"
              ]
            },
            " means the same thing as ",
            {
              "element": "literal",
              "content": [
                "[0-9]"
              ]
            },
            "."
          ]
        },
        {
          "element": "table",
          "content": [
            {
              "element": "tbody",
              "content": [
                {
                  "element": "tr",
                  "content": [
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            {
                              "element": "literal",
                              "content": [
                                "\\d"
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            "Any digit character"
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "element": "tr",
                  "content": [
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            {
                              "element": "literal",
                              "content": [
                                "\\w"
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            "An alphanumeric character (“word character”)"
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "element": "tr",
                  "content": [
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            {
                              "element": "literal",
                              "content": [
                                "\\s"
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            "Any whitespace character (space, tab, newline, and similar)"
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "element": "tr",
                  "content": [
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            {
                              "element": "literal",
                              "content": [
                                "\\D"
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            "A character that is ",
                            {
                              "element": "em",
                              "content": [
                                "not"
                              ]
                            },
                            " a digit"
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "element": "tr",
                  "content": [
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            {
                              "element": "literal",
                              "content": [
                                "\\W"
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            "A nonalphanumeric character"
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "element": "tr",
                  "content": [
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            {
                              "element": "literal",
                              "content": [
                                "\\S"
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            "A nonwhitespace character"
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "element": "tr",
                  "content": [
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            {
                              "element": "literal",
                              "content": [
                                "."
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            "Any character except for newline"
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "element": "p",
          "content": [
            "So you could match a date and time format like 30-01-2003 15:20 with the following expression:"
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "var dateTime = /\\d\\d-\\d\\d-\\d\\d\\d\\d \\d\\d:\\d\\d/;\nconsole.log(dateTime.test(\"30-01-2003 15:20\"));\n// → true\nconsole.log(dateTime.test(\"30-jan-2003 15:20\"));\n// → false"
        },
        {
          "element": "p",
          "content": [
            "That looks completely awful, doesn’t it? It has way too many backslashes, producing background noise that makes it hard to spot the actual pattern expressed. We’ll see a slightly improved version of this expression ",
            {
              "element": "reference",
              "content": [
                "later"
              ]
            },
            "."
          ]
        },
        {
          "element": "p",
          "content": [
            "These backslash codes can also be used inside square brackets. For example, ",
            {
              "element": "literal",
              "content": [
                "[\\d.]"
              ]
            },
            " means any digit or a period character. But note that the period itself, when used between square brackets, loses its special meaning. The same goes for other special characters, such as ",
            {
              "element": "literal",
              "content": [
                "+"
              ]
            },
            "."
          ]
        },
        {
          "element": "p",
          "content": [
            "To ",
            {
              "element": "em",
              "content": [
                "invert"
              ]
            },
            " a set of characters—that is, to express that you want to match any character ",
            {
              "element": "em",
              "content": [
                "except"
              ]
            },
            " the ones in the set—you can write a caret (",
            {
              "element": "literal",
              "content": [
                "^"
              ]
            },
            ") character after the opening bracket."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "var notBinary = /[^01]/;\nconsole.log(notBinary.test(\"1100100010100110\"));\n// → false\nconsole.log(notBinary.test(\"1100100010200110\"));\n// → true"
        }
      ],
      "title": "Matching a set of characters"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "We now know how to match a single digit. What if we want to match a whole number—a sequence of one or more digits?"
          ]
        },
        {
          "element": "p",
          "content": [
            "When you put a plus sign (",
            {
              "element": "literal",
              "content": [
                "+"
              ]
            },
            ") after something in a regular expression, it indicates that the element may be repeated more than once. Thus, ",
            {
              "element": "literal",
              "content": [
                "/\\d+/"
              ]
            },
            " matches one or more digit characters."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "console.log(/'\\d+'/.test(\"'123'\"));\n// → true\nconsole.log(/'\\d+'/.test(\"''\"));\n// → false\nconsole.log(/'\\d*'/.test(\"'123'\"));\n// → true\nconsole.log(/'\\d*'/.test(\"''\"));\n// → true"
        },
        {
          "element": "p",
          "content": [
            "The star (",
            {
              "element": "literal",
              "content": [
                "*"
              ]
            },
            ") has a similar meaning but also allows the pattern to match zero times. Something with a star after it never prevents a pattern from matching—it’ll just match zero instances if it can’t find any suitable text to match."
          ]
        },
        {
          "element": "p",
          "content": [
            "A question mark makes a part of a pattern “optional”, meaning it may occur zero or one time. In the following example, the ",
            {
              "element": "em",
              "content": [
                "u"
              ]
            },
            " character is allowed to occur, but the pattern also matches when it is missing."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "var neighbor = /neighbou?r/;\nconsole.log(neighbor.test(\"neighbour\"));\n// → true\nconsole.log(neighbor.test(\"neighbor\"));\n// → true"
        },
        {
          "element": "p",
          "content": [
            "To indicate that a pattern should occur a precise number of times, use curly braces. Putting ",
            {
              "element": "literal",
              "content": [
                "{4}"
              ]
            },
            " after an element, for example, requires it to occur exactly four times. It is also possible to specify a range this way: ",
            {
              "element": "literal",
              "content": [
                "{2,4}"
              ]
            },
            " means the element must occur at least twice and at most four times."
          ]
        },
        {
          "element": "p",
          "content": [
            "Here is another version of the date and time pattern that allows both single- and double-digit days, months, and hours. It is also slightly more readable."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "var dateTime = /\\d{1,2}-\\d{1,2}-\\d{4} \\d{1,2}:\\d{2}/;\nconsole.log(dateTime.test(\"30-1-2003 8:45\"));\n// → true"
        },
        {
          "element": "p",
          "content": [
            "You can also specify open-ended ranges when using curly braces by omitting the number after the comma. So ",
            {
              "element": "literal",
              "content": [
                "{5,}"
              ]
            },
            " means five or more times."
          ]
        }
      ],
      "title": "Repeating parts of a pattern"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "To use an operator like ",
            {
              "element": "literal",
              "content": [
                "*"
              ]
            },
            " or ",
            {
              "element": "literal",
              "content": [
                "+"
              ]
            },
            " on more than one element at a time, you can use parentheses. A part of a regular expression that is enclosed in parentheses counts as a single element as far as the operators following it are concerned."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "var cartoonCrying = /boo+(hoo+)+/i;\nconsole.log(cartoonCrying.test(\"Boohoooohoohooo\"));\n// → true"
        },
        {
          "element": "p",
          "content": [
            "The first and second ",
            {
              "element": "literal",
              "content": [
                "+"
              ]
            },
            " characters apply only to the second ",
            {
              "element": "em",
              "content": [
                "o"
              ]
            },
            " in ",
            {
              "element": "em",
              "content": [
                "boo"
              ]
            },
            " and ",
            {
              "element": "em",
              "content": [
                "hoo"
              ]
            },
            ", respectively. The third ",
            {
              "element": "literal",
              "content": [
                "+"
              ]
            },
            " applies to the whole group ",
            {
              "element": "literal",
              "content": [
                "(hoo+)"
              ]
            },
            ", matching one or more sequences like that."
          ]
        },
        {
          "element": "p",
          "content": [
            "The ",
            {
              "element": "literal",
              "content": [
                "i"
              ]
            },
            " at the end of the expression in the previous example makes this regular expression case insensitive, allowing it to match the uppercase ",
            {
              "element": "em",
              "content": [
                "B"
              ]
            },
            " in the input string, even though the pattern is itself all lowercase."
          ]
        }
      ],
      "title": "Grouping subexpressions"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "The ",
            {
              "element": "literal",
              "content": [
                "test"
              ]
            },
            " method is the absolute simplest way to match a regular expression. It tells you only whether it matched and nothing else. Regular expressions also have an ",
            {
              "element": "literal",
              "content": [
                "exec"
              ]
            },
            " (execute) method that will return ",
            {
              "element": "literal",
              "content": [
                "null"
              ]
            },
            " if no match was found and return an object with information about the match otherwise."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "var match = /\\d+/.exec(\"one two 100\");\nconsole.log(match);\n// → [\"100\"]\nconsole.log(match.index);\n// → 8"
        },
        {
          "element": "p",
          "content": [
            "An object returned from ",
            {
              "element": "literal",
              "content": [
                "exec"
              ]
            },
            " has an ",
            {
              "element": "literal",
              "content": [
                "index"
              ]
            },
            " property that tells us ",
            {
              "element": "em",
              "content": [
                "where"
              ]
            },
            " in the string the successful match begins. Other than that, the object looks like (and in fact is) an array of strings, whose first element is the string that was matched—in the previous example, this is the sequence of digits that we were looking for."
          ]
        },
        {
          "element": "p",
          "content": [
            "String values have a ",
            {
              "element": "literal",
              "content": [
                "match"
              ]
            },
            " method that behaves similarly."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "console.log(\"one two 100\".match(/\\d+/));\n// → [\"100\"]"
        },
        {
          "element": "p",
          "content": [
            "When the regular expression contains subexpressions grouped with parentheses, the text that matched those groups will also show up in the array. The whole match is always the first element. The next element is the part matched by the first group (the one whose opening parenthesis comes first in the expression), then the second group, and so on."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "var quotedText = /'([^']*)'/;\nconsole.log(quotedText.exec(\"she said 'hello'\"));\n// → [\"'hello'\", \"hello\"]"
        },
        {
          "element": "p",
          "content": [
            "When a group does not end up being matched at all (for example, when followed by a question mark), its position in the output array will hold ",
            {
              "element": "literal",
              "content": [
                "undefined"
              ]
            },
            ". Similarly, when a group is matched multiple times, only the last match ends up in the array."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "console.log(/bad(ly)?/.exec(\"bad\"));\n// → [\"bad\", undefined]\nconsole.log(/(\\d)+/.exec(\"123\"));\n// → [\"123\", \"3\"]"
        },
        {
          "element": "p",
          "content": [
            "Groups can be useful for extracting parts of a string. If we don’t just want to verify whether a string contains a date but also extract it and construct an object that represents it, we can wrap parentheses around the digit patterns and directly pick the date out of the result of ",
            {
              "element": "literal",
              "content": [
                "exec"
              ]
            },
            "."
          ]
        },
        {
          "element": "p",
          "content": [
            "But first, a brief detour, in which we discuss the preferred way to store date and time values in JavaScript."
          ]
        }
      ],
      "title": "Matches and groups"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "JavaScript has a standard object type for representing dates—or rather, points in time. It is called ",
            {
              "element": "literal",
              "content": [
                "Date"
              ]
            },
            ". If you simply create a date object using ",
            {
              "element": "literal",
              "content": [
                "new"
              ]
            },
            ", you get the current date and time."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "console.log(new Date());\n// → Wed Dec 04 2013 14:24:57 GMT+0100 (CET)"
        },
        {
          "element": "p",
          "content": [
            "You can also create an object for a specific time."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "console.log(new Date(2009, 11, 9));\n// → Wed Dec 09 2009 00:00:00 GMT+0100 (CET)\nconsole.log(new Date(2009, 11, 9, 12, 59, 59, 999));\n// → Wed Dec 09 2009 12:59:59 GMT+0100 (CET)"
        },
        {
          "element": "p",
          "content": [
            "JavaScript uses a convention where month numbers start at zero (so December is 11), yet day numbers start at one. This is confusing and silly. Be careful."
          ]
        },
        {
          "element": "p",
          "content": [
            "The last four arguments (hours, minutes, seconds, and milliseconds) are optional and taken to be zero when not given."
          ]
        },
        {
          "element": "p",
          "content": [
            "Timestamps are stored as the number of milliseconds since the start of 1970, using negative numbers for times before 1970 (following a convention set by “Unix time”, which was invented around that time). The ",
            {
              "element": "literal",
              "content": [
                "getTime"
              ]
            },
            " method on a date object returns this number. It is big, as you can imagine."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "console.log(new Date(2013, 11, 19).getTime());\n// → 1387407600000\nconsole.log(new Date(1387407600000));\n// → Thu Dec 19 2013 00:00:00 GMT+0100 (CET)"
        },
        {
          "element": "p",
          "content": [
            "If you give the ",
            {
              "element": "literal",
              "content": [
                "Date"
              ]
            },
            " constructor a single argument, that argument is treated as such a millisecond count. You can get the current millisecond count by creating a new ",
            {
              "element": "literal",
              "content": [
                "Date"
              ]
            },
            " object and calling ",
            {
              "element": "literal",
              "content": [
                "getTime"
              ]
            },
            " on it but also by calling the ",
            {
              "element": "literal",
              "content": [
                "Date.now"
              ]
            },
            " function."
          ]
        },
        {
          "element": "p",
          "content": [
            "Date objects provide methods like ",
            {
              "element": "literal",
              "content": [
                "getFullYear"
              ]
            },
            ", ",
            {
              "element": "literal",
              "content": [
                "getMonth"
              ]
            },
            ", ",
            {
              "element": "literal",
              "content": [
                "getDate"
              ]
            },
            ", ",
            {
              "element": "literal",
              "content": [
                "getHours"
              ]
            },
            ", ",
            {
              "element": "literal",
              "content": [
                "getMinutes"
              ]
            },
            ", and ",
            {
              "element": "literal",
              "content": [
                "getSeconds"
              ]
            },
            " to extract their components. There’s also ",
            {
              "element": "literal",
              "content": [
                "getYear"
              ]
            },
            ", which gives you a rather useless two-digit year value (such as ",
            {
              "element": "literal",
              "content": [
                "93"
              ]
            },
            " or ",
            {
              "element": "literal",
              "content": [
                "14"
              ]
            },
            ")."
          ]
        },
        {
          "element": "p",
          "content": [
            "Putting parentheses around the parts of the expression that we are interested in, we can now easily create a date object from a string."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "function findDate(string) {\n  var dateTime = /(\\d{1,2})-(\\d{1,2})-(\\d{4})/;\n  var match = dateTime.exec(string);\n  return new Date(Number(match[3]),\n                  Number(match[2]) - 1,\n                  Number(match[1]));\n}\nconsole.log(findDate(\"30-1-2003\"));\n// → Thu Jan 30 2003 00:00:00 GMT+0100 (CET)"
        }
      ],
      "title": "The date type"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "Unfortunately, ",
            {
              "element": "literal",
              "content": [
                "findDate"
              ]
            },
            " will also happily extract the nonsensical date 00-1-3000 from the string ",
            {
              "element": "literal",
              "content": [
                "\"100-1-30000\""
              ]
            },
            ". A match may happen anywhere in the string, so in this case, it’ll just start at the second character and end at the second-to-last character."
          ]
        },
        {
          "element": "p",
          "content": [
            "If we want to enforce that the match must span the whole string, we can add the markers ",
            {
              "element": "literal",
              "content": [
                "^"
              ]
            },
            " and ",
            {
              "element": "literal",
              "content": [
                "$"
              ]
            },
            ". The caret matches the start of the input string, while the dollar sign matches the end. So, ",
            {
              "element": "literal",
              "content": [
                "/^\\d+$/"
              ]
            },
            " matches a string consisting entirely of one or more digits, ",
            {
              "element": "literal",
              "content": [
                "/^!/"
              ]
            },
            " matches any string that starts with an exclamation mark, and ",
            {
              "element": "literal",
              "content": [
                "/x^/"
              ]
            },
            " does not match any string (there cannot be an ",
            {
              "element": "em",
              "content": [
                "x"
              ]
            },
            " before the start of the string)."
          ]
        },
        {
          "element": "p",
          "content": [
            "If, on the other hand, we just want to make sure the date starts and ends on a word boundary, we can use the marker ",
            {
              "element": "literal",
              "content": [
                "\\b"
              ]
            },
            ". A word boundary can be the start or end of the string or any point in the string that has a word character (as in ",
            {
              "element": "literal",
              "content": [
                "\\w"
              ]
            },
            ") on one side and a nonword character on the other."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "console.log(/cat/.test(\"concatenate\"));\n// → true\nconsole.log(/\\bcat\\b/.test(\"concatenate\"));\n// → false"
        },
        {
          "element": "p",
          "content": [
            "Note that a boundary marker doesn’t represent an actual character. It just enforces that the regular expression matches only when a certain condition holds at the place where it appears in the pattern."
          ]
        }
      ],
      "title": "Word and string boundaries"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "Say we want to know whether a piece of text contains not only a number but a number followed by one of the words ",
            {
              "element": "em",
              "content": [
                "pig"
              ]
            },
            ", ",
            {
              "element": "em",
              "content": [
                "cow"
              ]
            },
            ", or ",
            {
              "element": "em",
              "content": [
                "chicken"
              ]
            },
            ", or any of their plural forms."
          ]
        },
        {
          "element": "p",
          "content": [
            "We could write three regular expressions and test them in turn, but there is a nicer way. The pipe character (",
            {
              "element": "literal",
              "content": [
                "|"
              ]
            },
            ") denotes a choice between the pattern to its left and the pattern to its right. So I can say this:"
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "var animalCount = /\\b\\d+ (pig|cow|chicken)s?\\b/;\nconsole.log(animalCount.test(\"15 pigs\"));\n// → true\nconsole.log(animalCount.test(\"15 pigchickens\"));\n// → false"
        },
        {
          "element": "p",
          "content": [
            "Parentheses can be used to limit the part of the pattern that the pipe operator applies to, and you can put multiple such operators next to each other to express a choice between more than two patterns."
          ]
        }
      ],
      "title": "Choice patterns"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            " Regular expressions can be thought of as flow diagrams. This is the diagram for the livestock expression in the previous example:"
          ]
        },
        {
          "element": "img",
          "src": "img/re_pigchickens.svg"
        },
        {
          "element": "p",
          "content": [
            "Our expression matches a string if we can find a path from the left side of the diagram to the right side. We keep a current position in the string, and every time we move through a box, we verify that the part of the string after our current position matches that box."
          ]
        },
        {
          "element": "p",
          "content": [
            "So if we try to match ",
            {
              "element": "literal",
              "content": [
                "\"the 3 pigs\""
              ]
            },
            " with our regular expression, our progress through the flow chart would look like this:"
          ]
        },
        {
          "element": "ul",
          "content": [
            {
              "element": "item",
              "content": [
                {
                  "element": "p",
                  "content": [
                    "At position 4, there is a word boundary, so we can move past  the first box. "
                  ]
                }
              ]
            },
            {
              "element": "item",
              "content": [
                {
                  "element": "p",
                  "content": [
                    "Still at position 4, we find a digit, so we can also move past the  second box. "
                  ]
                }
              ]
            },
            {
              "element": "item",
              "content": [
                {
                  "element": "p",
                  "content": [
                    "At position 5, one path loops back to before the second (digit) box,  while the other moves forward through the box that holds a single space  character. There is a space here, not a digit, so we must take the  second path. "
                  ]
                }
              ]
            },
            {
              "element": "item",
              "content": [
                {
                  "element": "p",
                  "content": [
                    "We are now at position 6 (the start of “pigs”) and at the three-way  branch in the diagram. We don’t see “cow” or “chicken” here, but we  do see “pig”, so we take that branch. "
                  ]
                }
              ]
            },
            {
              "element": "item",
              "content": [
                {
                  "element": "p",
                  "content": [
                    "At position 9, after the three-way branch, one path skips  the ",
                    {
                      "element": "em",
                      "content": [
                        "s"
                      ]
                    },
                    " box and goes straight to the final word boundary, while the other path  matches an ",
                    {
                      "element": "em",
                      "content": [
                        "s"
                      ]
                    },
                    ". There is an ",
                    {
                      "element": "em",
                      "content": [
                        "s"
                      ]
                    },
                    " character here, not a word boundary,  so we go through the ",
                    {
                      "element": "em",
                      "content": [
                        "s"
                      ]
                    },
                    " box. "
                  ]
                }
              ]
            },
            {
              "element": "item",
              "content": [
                {
                  "element": "p",
                  "content": [
                    "We’re at position 10 (the end of the string) and can match only a  word boundary. The end of a string counts as a word boundary,  so we go through the last box and have successfully matched this  string. "
                  ]
                }
              ]
            }
          ]
        },
        {
          "element": "p",
          "content": [
            " Conceptually, a regular expression engine looks for a match in a string as follows: it starts at the start of the string and tries a match there. In this case, there ",
            {
              "element": "em",
              "content": [
                "is"
              ]
            },
            " a word boundary there, so it’d get past the first box—but there is no digit, so it’d fail at the second box. Then it moves on to the second character in the string and tries to begin a new match there... and so on, until it finds a match or reaches the end of the string and decides that there really is no match."
          ]
        }
      ],
      "title": "The mechanics of matching"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            " The regular expression ",
            {
              "element": "literal",
              "content": [
                "/\\b([01]+b|\\d+|[\\da-f]+h)\\b/"
              ]
            },
            " matches either a binary number followed by a ",
            {
              "element": "em",
              "content": [
                "b"
              ]
            },
            ", a regular decimal number with no suffix character, or a hexadecimal number (that is, base 16, with the letters ",
            {
              "element": "em",
              "content": [
                "a"
              ]
            },
            " to ",
            {
              "element": "em",
              "content": [
                "f"
              ]
            },
            " standing for the digits 10 to 15) followed by an ",
            {
              "element": "em",
              "content": [
                "h"
              ]
            },
            ". This is the corresponding diagram:"
          ]
        },
        {
          "element": "img",
          "src": "img/re_number.svg"
        },
        {
          "element": "p",
          "content": [
            "When matching this expression, it will often happen that the top (binary) branch is entered even though the input does not actually contain a binary number. When matching the string ",
            {
              "element": "literal",
              "content": [
                "\"103\""
              ]
            },
            ", for example, it becomes clear only at the 3 that we are in the wrong branch. The string ",
            {
              "element": "em",
              "content": [
                "does"
              ]
            },
            " match the expression, just not the branch we are currently in."
          ]
        },
        {
          "element": "p",
          "content": [
            "So the matcher ",
            {
              "element": "em",
              "content": [
                "backtracks"
              ]
            },
            ". When entering a branch, it remembers its current position (in this case, at the start of the string, just past the first boundary box in the diagram) so that it can go back and try another branch if the current one does not work out. For the string ",
            {
              "element": "literal",
              "content": [
                "\"103\""
              ]
            },
            ", after encountering the 3 character, it will start trying the branch for decimal numbers. This one matches, so a match is reported after all."
          ]
        },
        {
          "element": "p",
          "content": [
            "The matcher stops as soon as it finds a full match. This means that if multiple branches could potentially match a string, only the first one (ordered by where the branches appear in the regular expression) is used."
          ]
        },
        {
          "element": "p",
          "content": [
            "Backtracking also happens for repetition operators like + and ",
            {
              "element": "literal",
              "content": [
                "*"
              ]
            },
            ". If you match ",
            {
              "element": "literal",
              "content": [
                "/^.*x/"
              ]
            },
            " against ",
            {
              "element": "literal",
              "content": [
                "\"abcxe\""
              ]
            },
            ", the ",
            {
              "element": "literal",
              "content": [
                ".*"
              ]
            },
            " part will first try to consume the whole string. The engine will then realize that it needs an ",
            {
              "element": "em",
              "content": [
                "x"
              ]
            },
            " to match the pattern. Since there is no ",
            {
              "element": "em",
              "content": [
                "x"
              ]
            },
            " past the end of the string, the star operator tries to match one character less. But the matcher doesn’t find an ",
            {
              "element": "em",
              "content": [
                "x"
              ]
            },
            " after ",
            {
              "element": "literal",
              "content": [
                "abcx"
              ]
            },
            " either, so it backtracks again, matching the star operator to just ",
            {
              "element": "literal",
              "content": [
                "abc"
              ]
            },
            ". ",
            {
              "element": "em",
              "content": [
                "Now"
              ]
            },
            " it finds an ",
            {
              "element": "em",
              "content": [
                "x"
              ]
            },
            " where it needs it and reports a successful match from positions 0 to 4."
          ]
        },
        {
          "element": "p",
          "content": [
            "It is possible to write regular expressions that will do a ",
            {
              "element": "em",
              "content": [
                "lot"
              ]
            },
            " of backtracking. This problem occurs when a pattern can match a piece of input in many different ways. For example, if we get confused while writing a binary-number regular expression, we might accidentally write something like ",
            {
              "element": "literal",
              "content": [
                "/([01]+)+b/"
              ]
            },
            "."
          ]
        },
        {
          "element": "img",
          "src": "img/re_slow.svg"
        },
        {
          "element": "p",
          "content": [
            "If that tries to match some long series of zeros and ones with no trailing ",
            {
              "element": "em",
              "content": [
                "b"
              ]
            },
            " character, the matcher will first go through the inner loop until it runs out of digits. Then it notices there is no ",
            {
              "element": "em",
              "content": [
                "b"
              ]
            },
            ", so it backtracks one position, goes through the outer loop once, and gives up again, trying to backtrack out of the inner loop once more. It will continue to try every possible route through these two loops. This means the amount of work ",
            {
              "element": "em",
              "content": [
                "doubles"
              ]
            },
            " with each additional character. For even just a few dozen characters, the resulting match will take practically forever."
          ]
        }
      ],
      "title": "Backtracking"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "String values have a ",
            {
              "element": "literal",
              "content": [
                "replace"
              ]
            },
            " method, which can be used to replace part of the string with another string."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "console.log(\"papa\".replace(\"p\", \"m\"));\n// → mapa"
        },
        {
          "element": "p",
          "content": [
            " The first argument can also be a regular expression, in which case the first match of the regular expression is replaced. When a ",
            {
              "element": "literal",
              "content": [
                "g"
              ]
            },
            " option (for ",
            {
              "element": "em",
              "content": [
                "global"
              ]
            },
            ") is added to the regular expression, ",
            {
              "element": "em",
              "content": [
                "all"
              ]
            },
            " matches in the string will be replaced, not just the first."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "console.log(\"Borobudur\".replace(/[ou]/, \"a\"));\n// → Barobudur\nconsole.log(\"Borobudur\".replace(/[ou]/g, \"a\"));\n// → Barabadar"
        },
        {
          "element": "p",
          "content": [
            "It would have been sensible if the choice between replacing one match or all matches was made through an additional argument to ",
            {
              "element": "literal",
              "content": [
                "replace"
              ]
            },
            " or by providing a different method, ",
            {
              "element": "literal",
              "content": [
                "replaceAll"
              ]
            },
            ". But for some unfortunate reason, the choice relies on a property of the regular expression instead."
          ]
        },
        {
          "element": "p",
          "content": [
            "The real power of using regular expressions with ",
            {
              "element": "literal",
              "content": [
                "replace"
              ]
            },
            " comes from the fact that we can refer back to matched groups in the replacement string. For example, say we have a big string containing the names of people, one name per line, in the format ",
            {
              "element": "literal",
              "content": [
                "Lastname, Firstname"
              ]
            },
            ". If we want to swap these names and remove the comma to get a simple ",
            {
              "element": "literal",
              "content": [
                "Firstname Lastname"
              ]
            },
            " format, we can use the following code:"
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "console.log(\n  \"Hopper, Grace\\nMcCarthy, John\\nRitchie, Dennis\"\n    .replace(/([\\w ]+), ([\\w ]+)/g, \"$2 $1\"));\n// → Grace Hopper\n//   John McCarthy\n//   Dennis Ritchie"
        },
        {
          "element": "p",
          "content": [
            "The ",
            {
              "element": "literal",
              "content": [
                "$1"
              ]
            },
            " and ",
            {
              "element": "literal",
              "content": [
                "$2"
              ]
            },
            " in the replacement string refer to the parenthesized groups in the pattern. ",
            {
              "element": "literal",
              "content": [
                "$1"
              ]
            },
            " is replaced by the text that matched against the first group, ",
            {
              "element": "literal",
              "content": [
                "$2"
              ]
            },
            " by the second, and so on, up to ",
            {
              "element": "literal",
              "content": [
                "$9"
              ]
            },
            ". The whole match can be referred to with ",
            {
              "element": "literal",
              "content": [
                "$&"
              ]
            },
            "."
          ]
        },
        {
          "element": "p",
          "content": [
            "It is also possible to pass a function, rather than a string, as the second argument to ",
            {
              "element": "literal",
              "content": [
                "replace"
              ]
            },
            ". For each replacement, the function will be called with the matched groups (as well as the whole match) as arguments, and its return value will be inserted into the new string."
          ]
        },
        {
          "element": "p",
          "content": [
            "Here’s a simple example:"
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "var s = \"the cia and fbi\";\nconsole.log(s.replace(/\\b(fbi|cia)\\b/g, function(str) {\n  return str.toUpperCase();\n}));\n// → the CIA and FBI"
        },
        {
          "element": "p",
          "content": [
            "And here’s a more interesting one:"
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "var stock = \"1 lemon, 2 cabbages, and 101 eggs\";\nfunction minusOne(match, amount, unit) {\n  amount = Number(amount) - 1;\n  if (amount == 1) // only one left, remove the 's'\n    unit = unit.slice(0, unit.length - 1);\n  else if (amount == 0)\n    amount = \"no\";\n  return amount + \" \" + unit;\n}\nconsole.log(stock.replace(/(\\d+) (\\w+)/g, minusOne));\n// → no lemon, 1 cabbage, and 100 eggs"
        },
        {
          "element": "p",
          "content": [
            "This takes a string, finds all occurrences of a number followed by an alphanumeric word, and returns a string wherein every such occurrence is decremented by one."
          ]
        },
        {
          "element": "p",
          "content": [
            "The ",
            {
              "element": "literal",
              "content": [
                "(\\d+)"
              ]
            },
            " group ends up as the ",
            {
              "element": "literal",
              "content": [
                "amount"
              ]
            },
            " argument to the function, and the ",
            {
              "element": "literal",
              "content": [
                "(\\w+)"
              ]
            },
            " group gets bound to ",
            {
              "element": "literal",
              "content": [
                "unit"
              ]
            },
            ". The function converts ",
            {
              "element": "literal",
              "content": [
                "amount"
              ]
            },
            " to a number—which always works, since it matched ",
            {
              "element": "literal",
              "content": [
                "\\d+"
              ]
            },
            "—and makes some adjustments in case there is only one or zero left."
          ]
        }
      ],
      "title": "The replace method"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "It isn’t hard to use ",
            {
              "element": "literal",
              "content": [
                "replace"
              ]
            },
            " to write a function that removes all comments from a piece of JavaScript code. Here is a first attempt:"
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "function stripComments(code) {\n  return code.replace(/\\/\\/.*|\\/\\*[^]*\\*\\//g, \"\");\n}\nconsole.log(stripComments(\"1 + /* 2 */3\"));\n// → 1 + 3\nconsole.log(stripComments(\"x = 10;// ten!\"));\n// → x = 10;\nconsole.log(stripComments(\"1 /* a */+/* b */ 1\"));\n// → 1  1"
        },
        {
          "element": "p",
          "content": [
            "The part before the ",
            {
              "element": "em",
              "content": [
                "or"
              ]
            },
            " operator simply matches two slash characters followed by any number of non-newline characters. The part for multiline comments is more involved. We use ",
            {
              "element": "literal",
              "content": [
                "[^]"
              ]
            },
            " (any character that is not in the empty set of characters) as a way to match any character. We cannot just use a dot here because block comments can continue on a new line, and dots do not match the newline character."
          ]
        },
        {
          "element": "p",
          "content": [
            "But the output of the previous example appears to have gone wrong. Why?"
          ]
        },
        {
          "element": "p",
          "content": [
            "The ",
            {
              "element": "literal",
              "content": [
                "[^]*"
              ]
            },
            " part of the expression, as I described in the section on backtracking, will first match as much as it can. If that causes the next part of the pattern to fail, the matcher moves back one character and tries again from there. In the example, the matcher first tries to match the whole rest of the string and then moves back from there. It will find an occurrence of ",
            {
              "element": "literal",
              "content": [
                "*/"
              ]
            },
            " after going back four characters and match that. This is not what we wanted—the intention was to match a single comment, not to go all the way to the end of the code and find the end of the last block comment."
          ]
        },
        {
          "element": "p",
          "content": [
            "Because of this behavior, we say the repetition operators (",
            {
              "element": "literal",
              "content": [
                "+"
              ]
            },
            ", ",
            {
              "element": "literal",
              "content": [
                "*"
              ]
            },
            ", ",
            {
              "element": "literal",
              "content": [
                "?"
              ]
            },
            ", and ",
            {
              "element": "literal",
              "content": [
                "{}"
              ]
            },
            ") are ",
            {
              "element": "em",
              "content": [
                "greedy"
              ]
            },
            ", meaning they match as much as they can and backtrack from there. If you put a question mark after them (",
            {
              "element": "literal",
              "content": [
                "+?"
              ]
            },
            ", ",
            {
              "element": "literal",
              "content": [
                "*?"
              ]
            },
            ", ",
            {
              "element": "literal",
              "content": [
                "??"
              ]
            },
            ", ",
            {
              "element": "literal",
              "content": [
                "{}?"
              ]
            },
            "), they become nongreedy and start by matching as little as possible, matching more only when the remaining pattern does not fit the smaller match."
          ]
        },
        {
          "element": "p",
          "content": [
            "And that is exactly what we want in this case. By having the star match the smallest stretch of characters that brings us to a ",
            {
              "element": "literal",
              "content": [
                "*/"
              ]
            },
            ", we consume one block comment and nothing more."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "function stripComments(code) {\n  return code.replace(/\\/\\/.*|\\/\\*[^]*?\\*\\//g, \"\");\n}\nconsole.log(stripComments(\"1 /* a */+/* b */ 1\"));\n// → 1 + 1"
        },
        {
          "element": "p",
          "content": [
            "A lot of bugs in regular expression programs can be traced to unintentionally using a greedy operator where a nongreedy one would work better. When using a repetition operator, consider the nongreedy variant first."
          ]
        }
      ],
      "title": "Greed"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "There are cases where you might not know the exact pattern you need to match against when you are writing your code. Say you want to look for the user’s name in a piece of text and enclose it in underscore characters to make it stand out. Since you will know the name only once the program is actually running, you can’t use the slash-based notation."
          ]
        },
        {
          "element": "p",
          "content": [
            "But you can build up a string and use the ",
            {
              "element": "literal",
              "content": [
                "RegExp"
              ]
            },
            " constructor on that. Here’s an example:"
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "var name = \"harry\";\nvar text = \"Harry is a suspicious character.\";\nvar regexp = new RegExp(\"\\\\b(\" + name + \")\\\\b\", \"gi\");\nconsole.log(text.replace(regexp, \"_$1_\"));\n// → _Harry_ is a suspicious character."
        },
        {
          "element": "p",
          "content": [
            "When creating the ",
            {
              "element": "literal",
              "content": [
                "\\b"
              ]
            },
            " boundary markers, we have to use two backslashes because we are writing them in a normal string, not a slash-enclosed regular expression. The second argument to the ",
            {
              "element": "literal",
              "content": [
                "RegExp"
              ]
            },
            " constructor contains the options for the regular expression—in this case ",
            {
              "element": "literal",
              "content": [
                "\"gi\""
              ]
            },
            " for global and case-insensitive."
          ]
        },
        {
          "element": "p",
          "content": [
            "But what if the name is ",
            {
              "element": "literal",
              "content": [
                "\"dea+hl[]rd\""
              ]
            },
            " because our user is a nerdy teenager? That would result in a nonsensical regular expression, which won’t actually match the user’s name."
          ]
        },
        {
          "element": "p",
          "content": [
            " To work around this, we can add backslashes before any character that we don’t trust. Adding backslashes before alphabetic characters is a bad idea because things like ",
            {
              "element": "literal",
              "content": [
                "\\b"
              ]
            },
            " and ",
            {
              "element": "literal",
              "content": [
                "\\n"
              ]
            },
            " have a special meaning. But escaping everything that’s not alphanumeric or whitespace is safe."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "var name = \"dea+hl[]rd\";\nvar text = \"This dea+hl[]rd guy is super annoying.\";\nvar escaped = name.replace(/[^\\w\\s]/g, \"\\\\$&\");\nvar regexp = new RegExp(\"\\\\b(\" + escaped + \")\\\\b\", \"gi\");\nconsole.log(text.replace(regexp, \"_$1_\"));\n// → This _dea+hl[]rd_ guy is super annoying."
        }
      ],
      "title": "Dynamically creating RegExp objects"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "The ",
            {
              "element": "literal",
              "content": [
                "indexOf"
              ]
            },
            " method on strings cannot be called with a regular expression. But there is another method, ",
            {
              "element": "literal",
              "content": [
                "search"
              ]
            },
            ", which does expect a regular expression. Like ",
            {
              "element": "literal",
              "content": [
                "indexOf"
              ]
            },
            ", it returns the first index on which the expression was found, or -1 when it wasn’t found."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "console.log(\"  word\".search(/\\S/));\n// → 2\nconsole.log(\"    \".search(/\\S/));\n// → -1"
        },
        {
          "element": "p",
          "content": [
            "Unfortunately, there is no way to indicate that the match should start at a given offset (like we can with the second argument to ",
            {
              "element": "literal",
              "content": [
                "indexOf"
              ]
            },
            "), which would often be useful."
          ]
        }
      ],
      "title": "The search method"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "The ",
            {
              "element": "literal",
              "content": [
                "exec"
              ]
            },
            " method similarly does not provide a convenient way to start searching from a given position in the string. But it does provide an ",
            {
              "element": "em",
              "content": [
                "in"
              ]
            },
            "convenient way."
          ]
        },
        {
          "element": "p",
          "content": [
            "Regular expression objects have properties. One such property is ",
            {
              "element": "literal",
              "content": [
                "source"
              ]
            },
            ", which contains the string that expression was created from. Another property is ",
            {
              "element": "literal",
              "content": [
                "lastIndex"
              ]
            },
            ", which controls, in some limited circumstances, where the next match will start."
          ]
        },
        {
          "element": "p",
          "content": [
            " Those circumstances are that the regular expression must have the global (",
            {
              "element": "literal",
              "content": [
                "g"
              ]
            },
            ") option enabled, and the match must happen through the ",
            {
              "element": "literal",
              "content": [
                "exec"
              ]
            },
            " method. Again, a more sane solution would have been to just allow an extra argument to be passed to ",
            {
              "element": "literal",
              "content": [
                "exec"
              ]
            },
            ", but sanity is not a defining characteristic of JavaScript’s regular expression interface."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "var pattern = /y/g;\npattern.lastIndex = 3;\nvar match = pattern.exec(\"xyzzy\");\nconsole.log(match.index);\n// → 4\nconsole.log(pattern.lastIndex);\n// → 5"
        },
        {
          "element": "p",
          "content": [
            "If the match was successful, the call to ",
            {
              "element": "literal",
              "content": [
                "exec"
              ]
            },
            " automatically updates the ",
            {
              "element": "literal",
              "content": [
                "lastIndex"
              ]
            },
            " property to point after the match. If no match was found, ",
            {
              "element": "literal",
              "content": [
                "lastIndex"
              ]
            },
            " is set back to zero, which is also the value it has in a newly constructed regular expression object."
          ]
        },
        {
          "element": "p",
          "content": [
            "When using a global regular expression value for multiple ",
            {
              "element": "literal",
              "content": [
                "exec"
              ]
            },
            " calls, these automatic updates to the ",
            {
              "element": "literal",
              "content": [
                "lastIndex"
              ]
            },
            " property can cause problems. Your regular expression might be accidentally starting at an index that was left over from a previous call."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "var digit = /\\d/g;\nconsole.log(digit.exec(\"here it is: 1\"));\n// → [\"1\"]\nconsole.log(digit.exec(\"and now: 1\"));\n// → null"
        },
        {
          "element": "p",
          "content": [
            "Another interesting effect of the global option is that it changes the way the ",
            {
              "element": "literal",
              "content": [
                "match"
              ]
            },
            " method on strings works. When called with a global expression, instead of returning an array similar to that returned by ",
            {
              "element": "literal",
              "content": [
                "exec"
              ]
            },
            ", ",
            {
              "element": "literal",
              "content": [
                "match"
              ]
            },
            " will find ",
            {
              "element": "em",
              "content": [
                "all"
              ]
            },
            " matches of the pattern in the string and return an array containing the matched strings."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "console.log(\"Banana\".match(/an/g));\n// → [\"an\", \"an\"]"
        },
        {
          "element": "p",
          "content": [
            "So be cautious with global regular expressions. The cases where they are necessary—calls to ",
            {
              "element": "literal",
              "content": [
                "replace"
              ]
            },
            " and places where you want to explicitly use ",
            {
              "element": "literal",
              "content": [
                "lastIndex"
              ]
            },
            "—are typically the only places where you want to use them."
          ]
        },
        {
          "element": "section",
          "content": [
            {
              "element": "p",
              "content": [
                "A common pattern is to scan through all occurrences of a pattern in a string, in a way that gives us access to the match object in the loop body, by using ",
                {
                  "element": "literal",
                  "content": [
                    "lastIndex"
                  ]
                },
                " and ",
                {
                  "element": "literal",
                  "content": [
                    "exec"
                  ]
                },
                "."
              ]
            },
            {
              "element": "listing",
              "numbered": false,
              "content": "var input = \"A string with 3 numbers in it... 42 and 88.\";\nvar number = /\\b(\\d+)\\b/g;\nvar match;\nwhile (match = number.exec(input))\n  console.log(\"Found\", match[1], \"at\", match.index);\n// → Found 3 at 14\n//   Found 42 at 33\n//   Found 88 at 40"
            },
            {
              "element": "p",
              "content": [
                "This makes use of the fact that the value of an assignment expression (",
                {
                  "element": "literal",
                  "content": [
                    "="
                  ]
                },
                ") is the assigned value. So by using ",
                {
                  "element": "literal",
                  "content": [
                    "match = number.exec(input)"
                  ]
                },
                " as the condition in the ",
                {
                  "element": "literal",
                  "content": [
                    "while"
                  ]
                },
                " statement, we perform the match at the start of each iteration, save its result in a variable, and stop looping when no more matches are found."
              ]
            }
          ],
          "title": "Looping over matches"
        }
      ],
      "title": "The lastIndex property"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "To conclude the chapter, we’ll look at a problem that calls for regular expressions. Imagine we are writing a program to automatically harvest information about our enemies from the Internet. (We will not actually write that program here, just the part that reads the configuration file. Sorry to disappoint.) The configuration file looks like this:"
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "searchengine=http://www.google.com/search?q=$1\nspitefulness=9.7\n\n; comments are preceded by a semicolon...\n; each section concerns an individual enemy\n[larry]\nfullname=Larry Doe\ntype=kindergarten bully\nwebsite=http://www.geocities.com/CapeCanaveral/11451\n\n[gargamel]\nfullname=Gargamel\ntype=evil sorcerer\noutputdir=/home/marijn/enemies/gargamel"
        },
        {
          "element": "p",
          "content": [
            "The exact rules for this format (which is actually a widely used format, usually called an ",
            {
              "element": "em",
              "content": [
                "INI"
              ]
            },
            " file) are as follows:"
          ]
        },
        {
          "element": "ul",
          "content": [
            {
              "element": "item",
              "content": [
                {
                  "element": "p",
                  "content": [
                    "Blank lines and lines starting with semicolons are ignored. "
                  ]
                }
              ]
            },
            {
              "element": "item",
              "content": [
                {
                  "element": "p",
                  "content": [
                    "Lines wrapped in ",
                    {
                      "element": "literal",
                      "content": [
                        "["
                      ]
                    },
                    " and ",
                    {
                      "element": "literal",
                      "content": [
                        "]"
                      ]
                    },
                    " start a new section. "
                  ]
                }
              ]
            },
            {
              "element": "item",
              "content": [
                {
                  "element": "p",
                  "content": [
                    "Lines containing an alphanumeric identifier followed by an ",
                    {
                      "element": "literal",
                      "content": [
                        "="
                      ]
                    },
                    "  character add a setting to the current section. "
                  ]
                }
              ]
            },
            {
              "element": "item",
              "content": [
                {
                  "element": "p",
                  "content": [
                    "Anything else is invalid. "
                  ]
                }
              ]
            }
          ]
        },
        {
          "element": "p",
          "content": [
            "Our task is to convert a string like this into an array of objects, each with a ",
            {
              "element": "literal",
              "content": [
                "name"
              ]
            },
            " property and an array of settings. We’ll need one such object for each section and one for the global settings at the top."
          ]
        },
        {
          "element": "p",
          "content": [
            "Since the format has to be processed line by line, splitting up the file into separate lines is a good start. We used ",
            {
              "element": "literal",
              "content": [
                "string.split(\"\\n\")"
              ]
            },
            " to do this in ",
            {
              "element": "reference",
              "content": [
                "Chapter 6"
              ]
            },
            ". Some operating systems, however, use not just a newline character to separate lines but a carriage return character followed by a newline (",
            {
              "element": "literal",
              "content": [
                "\"\\r\\n\""
              ]
            },
            "). Given that the ",
            {
              "element": "literal",
              "content": [
                "split"
              ]
            },
            " method also allows a regular expression as its argument, we can split on a regular expression like ",
            {
              "element": "literal",
              "content": [
                "/\\r?\\n/"
              ]
            },
            " to split in a way that allows both ",
            {
              "element": "literal",
              "content": [
                "\"\\n\""
              ]
            },
            " and ",
            {
              "element": "literal",
              "content": [
                "\"\\r\\n\""
              ]
            },
            " between lines."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "function parseINI(string) {\n  // Start with an object to hold the top-level fields\n  var currentSection = {name: null, fields: []};\n  var categories = [currentSection];\n\n  string.split(/\\r?\\n/).forEach(function(line) {\n    var match;\n    if (/^\\s*(;.*)?$/.test(line)) {\n      return;\n    } else if (match = line.match(/^\\[(.*)\\]$/)) {\n      currentSection = {name: match[1], fields: []};\n      categories.push(currentSection);\n    } else if (match = line.match(/^(\\w+)=(.*)$/)) {\n      currentSection.fields.push({name: match[1],\n                                  value: match[2]});\n    } else {\n      throw new Error(\"Line '\" + line + \"' is invalid.\");\n    }\n  });\n\n  return categories;\n}"
        },
        {
          "element": "p",
          "content": [
            "This code goes over every line in the file, updating the “current section” object as it goes along. First, it checks whether the line can be ignored, using the expression ",
            {
              "element": "literal",
              "content": [
                "/^\\s*(;.*)?$/"
              ]
            },
            ". Do you see how it works? The part between the parentheses will match comments, and the ",
            {
              "element": "literal",
              "content": [
                "?"
              ]
            },
            " will make sure it also matches lines containing only whitespace."
          ]
        },
        {
          "element": "p",
          "content": [
            "If the line is not a comment, the code then checks whether the line starts a new section. If so, it creates a new current section object, to which subsequent settings will be added."
          ]
        },
        {
          "element": "p",
          "content": [
            "The last meaningful possibility is that the line is a normal setting, which the code adds to the current section object."
          ]
        },
        {
          "element": "p",
          "content": [
            "If a line matches none of these forms, the function throws an error."
          ]
        },
        {
          "element": "p",
          "content": [
            "Note the recurring use of ",
            {
              "element": "literal",
              "content": [
                "^"
              ]
            },
            " and ",
            {
              "element": "literal",
              "content": [
                "$"
              ]
            },
            " to make sure the expression matches the whole line, not just part of it. Leaving these out results in code that mostly works but behaves strangely for some input, which can be a difficult bug to track down."
          ]
        },
        {
          "element": "p",
          "content": [
            "The pattern ",
            {
              "element": "literal",
              "content": [
                "if (match= string.match(...))"
              ]
            },
            " is similar to the trick of using an assignment as the condition for ",
            {
              "element": "literal",
              "content": [
                "while"
              ]
            },
            ". You often aren’t sure that your call to ",
            {
              "element": "literal",
              "content": [
                "match"
              ]
            },
            " will succeed, so you can access the resulting object only inside an ",
            {
              "element": "literal",
              "content": [
                "if"
              ]
            },
            " statement that tests for this. To not break the pleasant chain of ",
            {
              "element": "literal",
              "content": [
                "if"
              ]
            },
            " forms, we assign the result of the match to a variable and immediately use that assignment as the test in the ",
            {
              "element": "literal",
              "content": [
                "if"
              ]
            },
            " statement."
          ]
        }
      ],
      "title": "Parsing an INI file"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "Because of JavaScript’s initial simplistic implementation and the fact that this simplistic approach was later set in stone as standard behavior, JavaScript’s regular expressions are rather dumb about characters that do not appear in the English language. For example, as far as JavaScript’s regular expressions are concerned, a “word character” is only one of the 26 characters in the Latin alphabet (uppercase or lowercase) and, for some reason, the underscore character. Things like ",
            {
              "element": "em",
              "content": [
                "é"
              ]
            },
            " or ",
            {
              "element": "em",
              "content": [
                "β"
              ]
            },
            ", which most definitely are word characters, will not match ",
            {
              "element": "literal",
              "content": [
                "\\w"
              ]
            },
            " (and ",
            {
              "element": "em",
              "content": [
                "will"
              ]
            },
            " match uppercase ",
            {
              "element": "literal",
              "content": [
                "\\W"
              ]
            },
            ", the nonword category)."
          ]
        },
        {
          "element": "p",
          "content": [
            "By a strange historical accident, ",
            {
              "element": "literal",
              "content": [
                "\\s"
              ]
            },
            " (whitespace) does not have this problem and matches all characters that the Unicode standard considers whitespace, including things like the nonbreaking space and the Mongolian vowel separator."
          ]
        },
        {
          "element": "p",
          "content": [
            "Some regular expression implementations in other programming languages have syntax to match specific Unicode character categories, such as “all uppercase letters”, “all punctuation”, or “control characters”. There are plans to add support for such categories to JavaScript, but it unfortunately looks like they won’t be realized in the near future."
          ]
        }
      ],
      "title": "International characters"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "Regular expressions are objects that represent patterns in strings. They use their own syntax to express these patterns."
          ]
        },
        {
          "element": "table",
          "content": [
            {
              "element": "tbody",
              "content": [
                {
                  "element": "tr",
                  "content": [
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            {
                              "element": "literal",
                              "content": [
                                "/abc/"
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            "A sequence of characters"
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "element": "tr",
                  "content": [
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            {
                              "element": "literal",
                              "content": [
                                "/[abc]/"
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            "Any character from a set of characters"
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "element": "tr",
                  "content": [
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            {
                              "element": "literal",
                              "content": [
                                "/[^abc]/"
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            "Any character ",
                            {
                              "element": "em",
                              "content": [
                                "not"
                              ]
                            },
                            " in a set of characters"
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "element": "tr",
                  "content": [
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            {
                              "element": "literal",
                              "content": [
                                "/[0-9]/"
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            "Any character in a range of characters"
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "element": "tr",
                  "content": [
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            {
                              "element": "literal",
                              "content": [
                                "/x+/"
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            "One or more occurrences of the pattern ",
                            {
                              "element": "literal",
                              "content": [
                                "x"
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "element": "tr",
                  "content": [
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            {
                              "element": "literal",
                              "content": [
                                "/x+?/"
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            "One or more occurrences, nongreedy"
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "element": "tr",
                  "content": [
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            {
                              "element": "literal",
                              "content": [
                                "/x*/"
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            "Zero or more occurrences"
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "element": "tr",
                  "content": [
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            {
                              "element": "literal",
                              "content": [
                                "/x?/"
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            "Zero or one occurrence"
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "element": "tr",
                  "content": [
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            {
                              "element": "literal",
                              "content": [
                                "/x{2,4}/"
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            "Between two and four occurrences"
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "element": "tr",
                  "content": [
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            {
                              "element": "literal",
                              "content": [
                                "/(abc)/"
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            "A group"
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "element": "tr",
                  "content": [
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            {
                              "element": "literal",
                              "content": [
                                "/a|b|c/"
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            "Any one of several patterns"
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "element": "tr",
                  "content": [
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            {
                              "element": "literal",
                              "content": [
                                "/\\d/"
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            "Any digit character"
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "element": "tr",
                  "content": [
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            {
                              "element": "literal",
                              "content": [
                                "/\\w/"
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            "An alphanumeric character (“word character”)"
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "element": "tr",
                  "content": [
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            {
                              "element": "literal",
                              "content": [
                                "/\\s/"
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            "Any whitespace character"
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "element": "tr",
                  "content": [
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            {
                              "element": "literal",
                              "content": [
                                "/./"
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            "Any character except newlines"
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "element": "tr",
                  "content": [
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            {
                              "element": "literal",
                              "content": [
                                "/\\b/"
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            "A word boundary"
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "element": "tr",
                  "content": [
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            {
                              "element": "literal",
                              "content": [
                                "/^/"
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            "Start of input"
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "element": "tr",
                  "content": [
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            {
                              "element": "literal",
                              "content": [
                                "/$/"
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "element": "td",
                      "align": "left",
                      "valign": "top",
                      "content": [
                        {
                          "element": "p",
                          "content": [
                            "End of input"
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "element": "p",
          "content": [
            "A regular expression has a method ",
            {
              "element": "literal",
              "content": [
                "test"
              ]
            },
            " to test whether a given string matches it. It also has an ",
            {
              "element": "literal",
              "content": [
                "exec"
              ]
            },
            " method that, when a match is found, returns an array containing all matched groups. Such an array has an ",
            {
              "element": "literal",
              "content": [
                "index"
              ]
            },
            " property that indicates where the match started."
          ]
        },
        {
          "element": "p",
          "content": [
            "Strings have a ",
            {
              "element": "literal",
              "content": [
                "match"
              ]
            },
            " method to match them against a regular expression and a ",
            {
              "element": "literal",
              "content": [
                "search"
              ]
            },
            " method to search for one, returning only the starting position of the match. Their ",
            {
              "element": "literal",
              "content": [
                "replace"
              ]
            },
            " method can replace matches of a pattern with a replacement string. Alternatively, you can pass a function to ",
            {
              "element": "literal",
              "content": [
                "replace"
              ]
            },
            ", which will be used to build up a replacement string based on the match text and matched groups."
          ]
        },
        {
          "element": "p",
          "content": [
            "Regular expressions can have options, which are written after the closing slash. The ",
            {
              "element": "literal",
              "content": [
                "i"
              ]
            },
            " option makes the match case insensitive, while the ",
            {
              "element": "literal",
              "content": [
                "g"
              ]
            },
            " option makes the expression ",
            {
              "element": "em",
              "content": [
                "global"
              ]
            },
            ", which, among other things, causes the ",
            {
              "element": "literal",
              "content": [
                "replace"
              ]
            },
            " method to replace all instances instead of just the first."
          ]
        },
        {
          "element": "p",
          "content": [
            "The ",
            {
              "element": "literal",
              "content": [
                "RegExp"
              ]
            },
            " constructor can be used to create a regular expression value from a string."
          ]
        },
        {
          "element": "p",
          "content": [
            "Regular expressions are a sharp tool with an awkward handle. They simplify some tasks tremendously but can quickly become unmanageable when applied to complex problems. Part of knowing how to use them is resisting the urge to try to shoehorn things that they cannot sanely express into them."
          ]
        }
      ],
      "title": "Summary"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "It is almost unavoidable that, in the course of working on these exercises, you will get confused and frustrated by some regular expression’s inexplicable behavior. Sometimes it helps to enter your expression into an online tool like ",
            {
              "element": "reference",
              "content": [
                {
                  "element": "em",
                  "content": [
                    "debuggex.com"
                  ]
                }
              ]
            },
            " to see whether its visualization corresponds to what you intended and to experiment with the way it responds to various input strings."
          ]
        },
        {
          "element": "section",
          "content": [
            {
              "element": "p",
              "content": [
                {
                  "element": "em",
                  "content": [
                    "Codegolf"
                  ]
                },
                " is a term used for the game of trying to express a particular program in as few characters as possible. Similarly, ",
                {
                  "element": "em",
                  "content": [
                    "regexp golf"
                  ]
                },
                " is the practice of writing as tiny a regular expression as possible to match a given pattern, and ",
                {
                  "element": "em",
                  "content": [
                    "only"
                  ]
                },
                " that pattern."
              ]
            },
            {
              "element": "p",
              "content": [
                "For each of the following items, write a regular expression to test whether any of the given substrings occur in a string. The regular expression should match only strings containing one of the substrings described. Do not worry about word boundaries unless explicitly mentioned. When your expression works, see whether you can make it any smaller."
              ]
            },
            {
              "element": "ol",
              "content": [
                {
                  "element": "item",
                  "content": [
                    {
                      "element": "p",
                      "content": [
                        "",
                        {
                          "element": "em",
                          "content": [
                            "car"
                          ]
                        },
                        " and ",
                        {
                          "element": "em",
                          "content": [
                            "cat"
                          ]
                        },
                        " "
                      ]
                    }
                  ]
                },
                {
                  "element": "item",
                  "content": [
                    {
                      "element": "p",
                      "content": [
                        "",
                        {
                          "element": "em",
                          "content": [
                            "pop"
                          ]
                        },
                        " and ",
                        {
                          "element": "em",
                          "content": [
                            "prop"
                          ]
                        },
                        " "
                      ]
                    }
                  ]
                },
                {
                  "element": "item",
                  "content": [
                    {
                      "element": "p",
                      "content": [
                        "",
                        {
                          "element": "em",
                          "content": [
                            "ferret"
                          ]
                        },
                        ", ",
                        {
                          "element": "em",
                          "content": [
                            "ferry"
                          ]
                        },
                        ", and ",
                        {
                          "element": "em",
                          "content": [
                            "ferrari"
                          ]
                        },
                        " "
                      ]
                    }
                  ]
                },
                {
                  "element": "item",
                  "content": [
                    {
                      "element": "p",
                      "content": [
                        "Any word ending in ",
                        {
                          "element": "em",
                          "content": [
                            "ious"
                          ]
                        },
                        " "
                      ]
                    }
                  ]
                },
                {
                  "element": "item",
                  "content": [
                    {
                      "element": "p",
                      "content": [
                        "A whitespace character followed by a dot, comma, colon, or semicolon "
                      ]
                    }
                  ]
                },
                {
                  "element": "item",
                  "content": [
                    {
                      "element": "p",
                      "content": [
                        "A word longer than six letters "
                      ]
                    }
                  ]
                },
                {
                  "element": "item",
                  "content": [
                    {
                      "element": "p",
                      "content": [
                        "A word without the letter ",
                        {
                          "element": "em",
                          "content": [
                            "e"
                          ]
                        },
                        " "
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "element": "p",
              "content": [
                "Refer to the table in the ",
                {
                  "element": "reference",
                  "content": [
                    "chapter summary"
                  ]
                },
                " for help. Test each solution with a few test strings."
              ]
            }
          ],
          "title": "Regexp golf"
        },
        {
          "element": "section",
          "content": [
            {
              "element": "p",
              "content": [
                "Imagine you have written a story and used single quotation marks throughout to mark pieces of dialogue. Now you want to replace all the dialogue quotes with double quotes, while keeping the single quotes used in contractions like ",
                {
                  "element": "em",
                  "content": [
                    "aren’t"
                  ]
                },
                "."
              ]
            },
            {
              "element": "p",
              "content": [
                "Think of a pattern that distinguishes these two kinds of quote usage and craft a call to the ",
                {
                  "element": "literal",
                  "content": [
                    "replace"
                  ]
                },
                " method that does the proper replacement."
              ]
            },
            {
              "element": "hint",
              "content": [
                {
                  "element": "p",
                  "content": [
                    "The most obvious solution is to only replace quotes with a nonword character on at least one side. Something like ",
                    {
                      "element": "literal",
                      "content": [
                        "/\\W'|'\\W/"
                      ]
                    },
                    ". But you also have to take the start and end of the line into account."
                  ]
                },
                {
                  "element": "p",
                  "content": [
                    "In addition, you must ensure that the replacement also includes the characters that were matched by the ",
                    {
                      "element": "literal",
                      "content": [
                        "\\W"
                      ]
                    },
                    " pattern so that those are not dropped. This can be done by wrapping them in parentheses and including their groups in the replacement string (",
                    {
                      "element": "literal",
                      "content": [
                        "$1"
                      ]
                    },
                    ", ",
                    {
                      "element": "literal",
                      "content": [
                        "$2"
                      ]
                    },
                    "). Groups that are not matched will be replaced by nothing."
                  ]
                }
              ]
            }
          ],
          "title": "Quoting style"
        },
        {
          "element": "section",
          "content": [
            {
              "element": "p",
              "content": [
                "A series of digits can be matched by the simple regular expression ",
                {
                  "element": "literal",
                  "content": [
                    "/\\d+/"
                  ]
                },
                "."
              ]
            },
            {
              "element": "p",
              "content": [
                "Write an expression that matches only JavaScript-style numbers. It must support an optional minus ",
                {
                  "element": "em",
                  "content": [
                    "or"
                  ]
                },
                " plus sign in front of the number, the decimal dot, and exponent notation—",
                {
                  "element": "literal",
                  "content": [
                    "5e-3"
                  ]
                },
                " or ",
                {
                  "element": "literal",
                  "content": [
                    "1E10"
                  ]
                },
                "— again with an optional sign in front of the exponent. Also note that it is not necessary for there to be digits in front of or after the dot, but the number cannot be a dot alone. That is, ",
                {
                  "element": "literal",
                  "content": [
                    ".5"
                  ]
                },
                " and ",
                {
                  "element": "literal",
                  "content": [
                    "5."
                  ]
                },
                " are valid JavaScript numbers, but a lone dot ",
                {
                  "element": "em",
                  "content": [
                    "isn’t"
                  ]
                },
                "."
              ]
            },
            {
              "element": "hint",
              "content": [
                {
                  "element": "p",
                  "content": [
                    "First, do not forget the backslash in front of the dot."
                  ]
                },
                {
                  "element": "p",
                  "content": [
                    "Matching the optional sign in front of the number, as well as in front of the exponent, can be done with ",
                    {
                      "element": "literal",
                      "content": [
                        "[+\\-]?"
                      ]
                    },
                    " or ",
                    {
                      "element": "literal",
                      "content": [
                        "(\\+|-|)"
                      ]
                    },
                    " (plus, minus, or nothing)."
                  ]
                },
                {
                  "element": "p",
                  "content": [
                    "The more complicated part of the exercise is the problem of matching both ",
                    {
                      "element": "literal",
                      "content": [
                        "\"5.\""
                      ]
                    },
                    " and ",
                    {
                      "element": "literal",
                      "content": [
                        "\".5\""
                      ]
                    },
                    " without also matching ",
                    {
                      "element": "literal",
                      "content": [
                        "\".\""
                      ]
                    },
                    ". For this, a good solution is to use the ",
                    {
                      "element": "literal",
                      "content": [
                        "|"
                      ]
                    },
                    " operator to separate the two cases—either one or more digits optionally followed by a dot and zero or more digits ",
                    {
                      "element": "em",
                      "content": [
                        "or"
                      ]
                    },
                    " a dot followed by one or more digits."
                  ]
                },
                {
                  "element": "p",
                  "content": [
                    "Finally, to make the ",
                    {
                      "element": "em",
                      "content": [
                        "e"
                      ]
                    },
                    " case-insensitive, either add an ",
                    {
                      "element": "literal",
                      "content": [
                        "i"
                      ]
                    },
                    " option to the regular expression or use ",
                    {
                      "element": "literal",
                      "content": [
                        "[eE]"
                      ]
                    },
                    "."
                  ]
                }
              ]
            }
          ],
          "title": "Numbers again"
        }
      ],
      "title": "Exercises"
    }
  ],
  "title": "Regular Expressions"
}
