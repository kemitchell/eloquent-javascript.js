{
  "content": [
    {
      "element": "blockquote",
      "attribution": "Charles Babbage Passages from the Life of a Philosopher (1864)",
      "content": [
        {
          "element": "p",
          "content": [
            "On two occasions I have been asked, ‘Pray, Mr. Babbage, if you put into the machine wrong figures, will the right answers come out?’ [...] I am not able rightly to apprehend the kind of confusion of ideas that could provoke such a question."
          ]
        }
      ]
    },
    {
      "element": "p",
      "content": [
        "Numbers, Booleans, and strings are the bricks that data structures are built from. But you can’t make much of a house out of a single brick. ",
        {
          "element": "em",
          "content": [
            "Objects"
          ]
        },
        " allow us to group values—including other objects—together and thus build more complex structures."
      ]
    },
    {
      "element": "p",
      "content": [
        "The programs we have built so far have been seriously hampered by the fact that they were operating only on simple data types. This chapter will add a basic understanding of data structures to your toolkit. By the end of it, you’ll know enough to start writing some useful programs."
      ]
    },
    {
      "element": "p",
      "content": [
        "The chapter will work through a more or less realistic programming example, introducing concepts as they apply to the problem at hand. The example code will often build on functions and variables that were introduced earlier in the text."
      ]
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "Every now and then, usually between eight and ten in the evening, Jacques finds himself transforming into a small furry rodent with a bushy tail."
          ]
        },
        {
          "element": "p",
          "content": [
            "On one hand, Jacques is quite glad that he doesn’t have classic lycanthropy. Turning into a squirrel tends to cause fewer problems than turning into a wolf. Instead of having to worry about accidentally eating the neighbor (",
            {
              "element": "em",
              "content": [
                "that"
              ]
            },
            " would be awkward), he worries about being eaten by the neighbor’s cat. After two occasions where he woke up on a precariously thin branch in the crown of an oak, naked and disoriented, he has taken to locking the doors and windows of his room at night and putting a few walnuts on the floor to keep himself busy."
          ]
        },
        {
          "element": "img",
          "src": "img/weresquirrel.png"
        },
        {
          "element": "p",
          "content": [
            "That takes care of the cat and oak problems. But Jacques still suffers from his condition. The irregular occurrences of the transformation make him suspect that they might be triggered by something. For a while, he believed that it happened only on days when he had touched trees. So he stopped touching trees entirely and even avoided going near them. But the problem persisted."
          ]
        },
        {
          "element": "p",
          "content": [
            "Switching to a more scientific approach, Jacques intends to start keeping a daily log of everything he did that day and whether he changed form. With this data he hopes to narrow down the conditions that trigger the transformations."
          ]
        },
        {
          "element": "p",
          "content": [
            "The first thing he does is design a data structure to store this information."
          ]
        }
      ],
      "title": "The weresquirrel"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "To work with a chunk of digital data, we’ll first have to find a way to represent it in our machine’s memory. Say, as a simple example, that we want to represent a collection of numbers: 2, 3, 5, 7, and 11."
          ]
        },
        {
          "element": "p",
          "content": [
            "We could get creative with strings—after all, strings can be any length, so we can put a lot of data into them—and use ",
            {
              "element": "literal",
              "content": [
                "\"2 35 7 11\""
              ]
            },
            " as our representation. But this is awkward. You’d have to somehow extract the digits and convert them back to numbers to access them."
          ]
        },
        {
          "element": "p",
          "content": [
            "Fortunately, JavaScript provides a data type specifically for storing sequences of values. It is called an ",
            {
              "element": "em",
              "content": [
                "array"
              ]
            },
            " and is written as a list of values between square brackets, separated by commas."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "var listOfNumbers = [2, 3, 5, 7, 11];\nconsole.log(listOfNumbers[1]);\n// → 3\nconsole.log(listOfNumbers[1 - 1]);\n// → 2"
        },
        {
          "element": "p",
          "content": [
            "The notation for getting at the elements inside an array also uses square brackets. A pair of square brackets immediately after an expression, with another expression inside of them, will look up the element in the left-hand expression that corresponds to the ",
            {
              "element": "em",
              "content": [
                "index"
              ]
            },
            " given by the expression in the brackets."
          ]
        },
        {
          "element": "p",
          "content": [
            "The first index of an array is zero, not one. So the first element can be read with ",
            {
              "element": "literal",
              "content": [
                "listOfNumbers[0]"
              ]
            },
            ". If you don’t have a programming background, this convention might take some getting used to. But zero-based counting has a long tradition in technology, and as long as this convention is followed consistently (which it is, in JavaScript), it works well."
          ]
        }
      ],
      "title": "Data sets"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            " We’ve seen a few suspicious-looking expressions like ",
            {
              "element": "literal",
              "content": [
                "myString.length"
              ]
            },
            " (to get the length of a string) and ",
            {
              "element": "literal",
              "content": [
                "Math.max"
              ]
            },
            " (the maximum function) in past examples. These are expressions that access a ",
            {
              "element": "em",
              "content": [
                "property"
              ]
            },
            " of some value. In the first case, we access the ",
            {
              "element": "literal",
              "content": [
                "length"
              ]
            },
            " property of the value in ",
            {
              "element": "literal",
              "content": [
                "myString"
              ]
            },
            ". In the second, we access the property named ",
            {
              "element": "literal",
              "content": [
                "max"
              ]
            },
            " in the ",
            {
              "element": "literal",
              "content": [
                "Math"
              ]
            },
            " object (which is a collection of mathematics-related values and functions)."
          ]
        },
        {
          "element": "p",
          "content": [
            "Almost all JavaScript values have properties. The exceptions are ",
            {
              "element": "literal",
              "content": [
                "null"
              ]
            },
            " and ",
            {
              "element": "literal",
              "content": [
                "undefined"
              ]
            },
            ". If you try to access a property on one of these nonvalues, you get an error."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "null.length;\n// → TypeError: Cannot read property 'length' of null"
        },
        {
          "element": "p",
          "content": [
            "The two most common ways to access properties in JavaScript are with a dot and with square brackets. Both ",
            {
              "element": "literal",
              "content": [
                "value.x"
              ]
            },
            " and ",
            {
              "element": "literal",
              "content": [
                "value[x]"
              ]
            },
            " access a property on ",
            {
              "element": "literal",
              "content": [
                "value"
              ]
            },
            "—but not necessarily the same property. The difference is in how ",
            {
              "element": "literal",
              "content": [
                "x"
              ]
            },
            " is interpreted. When using a dot, the part after the dot must be a valid variable name, and it directly names the property. When using square brackets, the expression between the brackets is ",
            {
              "element": "em",
              "content": [
                "evaluated"
              ]
            },
            " to get the property name. Whereas ",
            {
              "element": "literal",
              "content": [
                "value.x"
              ]
            },
            " fetches the property of ",
            {
              "element": "literal",
              "content": [
                "value"
              ]
            },
            " named “x”, ",
            {
              "element": "literal",
              "content": [
                "value[x]"
              ]
            },
            " tries to evaluate the expression ",
            {
              "element": "literal",
              "content": [
                "x"
              ]
            },
            " and uses the result as the property name."
          ]
        },
        {
          "element": "p",
          "content": [
            "So if you know that the property you are interested in is called “length”, you say ",
            {
              "element": "literal",
              "content": [
                "value.length"
              ]
            },
            ". If you want to extract the property named by the value held in the variable ",
            {
              "element": "literal",
              "content": [
                "i"
              ]
            },
            ", you say ",
            {
              "element": "literal",
              "content": [
                "value[i]"
              ]
            },
            ". And because property names can be any string, if you want to access a property named “2” or “John Doe”, you must use square brackets: ",
            {
              "element": "literal",
              "content": [
                "value[2]"
              ]
            },
            " or ",
            {
              "element": "literal",
              "content": [
                "value[\"John Doe\"]"
              ]
            },
            ". This is the case even though you know the precise name of the property in advance, because neither “2” nor “John Doe” is a valid variable name and so cannot be accessed through dot notation."
          ]
        },
        {
          "element": "p",
          "content": [
            " The elements in an array are stored in properties. Because the names of these properties are numbers and we often need to get their name from a variable, we have to use the bracket syntax to access them. The ",
            {
              "element": "literal",
              "content": [
                "length"
              ]
            },
            " property of an array tells us how many elements it contains. This property name is a valid variable name, and we know its name in advance, so to find the length of an array, you typically write ",
            {
              "element": "literal",
              "content": [
                "array.length"
              ]
            },
            " because that is easier to write than ",
            {
              "element": "literal",
              "content": [
                "array[\"length\"]"
              ]
            },
            "."
          ]
        }
      ],
      "title": "Properties"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "Both string and array objects contain, in addition to the ",
            {
              "element": "literal",
              "content": [
                "length"
              ]
            },
            " property, a number of properties that refer to function values."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "var doh = \"Doh\";\nconsole.log(typeof doh.toUpperCase);\n// → function\nconsole.log(doh.toUpperCase());\n// → DOH"
        },
        {
          "element": "p",
          "content": [
            "Every string has a ",
            {
              "element": "literal",
              "content": [
                "toUpperCase"
              ]
            },
            " property. When called, it will return a copy of the string, in which all letters have been converted to uppercase. There is also ",
            {
              "element": "literal",
              "content": [
                "toLowerCase"
              ]
            },
            ". You can guess what that does."
          ]
        },
        {
          "element": "p",
          "content": [
            "Interestingly, even though the call to ",
            {
              "element": "literal",
              "content": [
                "toUpperCase"
              ]
            },
            " does not pass any arguments, the function somehow has access to the string ",
            {
              "element": "literal",
              "content": [
                "\"Doh\""
              ]
            },
            ", the value whose property we called. How this works is described in ",
            {
              "element": "reference",
              "content": [
                "Chapter 6"
              ]
            },
            "."
          ]
        },
        {
          "element": "p",
          "content": [
            "Properties that contain functions are generally called ",
            {
              "element": "em",
              "content": [
                "methods"
              ]
            },
            " of the value they belong to. As in, “",
            {
              "element": "literal",
              "content": [
                "toUpperCase"
              ]
            },
            " is a method of a string”."
          ]
        },
        {
          "element": "p",
          "content": [
            "This example demonstrates some methods that array objects have:"
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "var mack = [];\nmack.push(\"Mack\");\nmack.push(\"the\", \"Knife\");\nconsole.log(mack);\n// → [\"Mack\", \"the\", \"Knife\"]\nconsole.log(mack.join(\" \"));\n// → Mack the Knife\nconsole.log(mack.pop());\n// → Knife\nconsole.log(mack);\n// → [\"Mack\", \"the\"]"
        },
        {
          "element": "p",
          "content": [
            "The ",
            {
              "element": "literal",
              "content": [
                "push"
              ]
            },
            " method can be used to add values to the end of an array. The ",
            {
              "element": "literal",
              "content": [
                "pop"
              ]
            },
            " method does the opposite: it removes the value at the end of the array and returns it. An array of strings can be flattened to a single string with the ",
            {
              "element": "literal",
              "content": [
                "join"
              ]
            },
            " method. The argument given to ",
            {
              "element": "literal",
              "content": [
                "join"
              ]
            },
            " determines the text that is glued between the array’s elements."
          ]
        }
      ],
      "title": "Methods"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "Back to the weresquirrel. A set of daily log entries can be represented as an array. But the entries do not consist of just a number or a string—each entry needs to store a list of activities and a Boolean value that indicates whether Jacques turned into a squirrel. Ideally, we would like to group these values together into a single value and then put these grouped values into an array of log entries."
          ]
        },
        {
          "element": "p",
          "content": [
            "Values of the type ",
            {
              "element": "em",
              "content": [
                "object"
              ]
            },
            " are arbitrary collections of properties, and we can add or remove these properties as we please. One way to create an object is by using a curly brace notation."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "var day1 = {\n  squirrel: false,\n  events: [\"work\", \"touched tree\", \"pizza\", \"running\",\n           \"television\"]\n};\nconsole.log(day1.squirrel);\n// → false\nconsole.log(day1.wolf);\n// → undefined\nday1.wolf = false;\nconsole.log(day1.wolf);\n// → false"
        },
        {
          "element": "p",
          "content": [
            "Inside the curly braces, we can give a list of properties separated by commas. Each property is written as a name, followed by a colon, followed by an expression that provides a value for the property. Spaces and line breaks are not significant. When an object spans multiple lines, indenting it like in the previous example improves readability. Properties whose names are not valid variable names or valid numbers have to be quoted."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "var descriptions = {\n  work: \"Went to work\",\n  \"touched tree\": \"Touched a tree\"\n};"
        },
        {
          "element": "p",
          "content": [
            "This means that curly braces have ",
            {
              "element": "em",
              "content": [
                "two"
              ]
            },
            " meanings in JavaScript. At the start of a statement, they start a block of statements. In any other position, they describe an object. Fortunately, it is almost never useful to start a statement with a curly-brace object, and in typical programs, there is no ambiguity between these two uses."
          ]
        },
        {
          "element": "p",
          "content": [
            "Reading a property that doesn’t exist will produce the value ",
            {
              "element": "literal",
              "content": [
                "undefined"
              ]
            },
            ", which happens the first time we try to read the ",
            {
              "element": "literal",
              "content": [
                "wolf"
              ]
            },
            " property in the previous example."
          ]
        },
        {
          "element": "p",
          "content": [
            "It is possible to assign a value to a property expression with the ",
            {
              "element": "literal",
              "content": [
                "="
              ]
            },
            " operator. This will replace the property’s value if it already existed or create a new property on the object if it didn’t."
          ]
        },
        {
          "element": "p",
          "content": [
            "To briefly return to our tentacle model of variable bindings—property bindings are similar. They ",
            {
              "element": "em",
              "content": [
                "grasp"
              ]
            },
            " values, but other variables and properties might be holding onto those same values. You may think of objects as octopuses with any number of tentacles, each of which has a name inscribed on it."
          ]
        },
        {
          "element": "img",
          "src": "img/octopus-object.jpg"
        },
        {
          "element": "p",
          "content": [
            "The ",
            {
              "element": "literal",
              "content": [
                "delete"
              ]
            },
            " operator cuts off a tentacle from such an octopus. It is a unary operator that, when applied to a property access expression, will remove the named property from the object. This is not a common thing to do, but it is possible."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "var anObject = {left: 1, right: 2};\nconsole.log(anObject.left);\n// → 1\ndelete anObject.left;\nconsole.log(anObject.left);\n// → undefined\nconsole.log(\"left\" in anObject);\n// → false\nconsole.log(\"right\" in anObject);\n// → true"
        },
        {
          "element": "p",
          "content": [
            "The binary ",
            {
              "element": "literal",
              "content": [
                "in"
              ]
            },
            " operator, when applied to a string and an object, returns a Boolean value that indicates whether that object has that property. The difference between setting a property to ",
            {
              "element": "literal",
              "content": [
                "undefined"
              ]
            },
            " and actually deleting it is that, in the first case, the object still ",
            {
              "element": "em",
              "content": [
                "has"
              ]
            },
            " the property (it just doesn’t have a very interesting value), whereas in the second case the property is no longer present and ",
            {
              "element": "literal",
              "content": [
                "in"
              ]
            },
            " will return ",
            {
              "element": "literal",
              "content": [
                "false"
              ]
            },
            "."
          ]
        },
        {
          "element": "p",
          "content": [
            "Arrays, then, are just a kind of object specialized for storing sequences of things. If you evaluate ",
            {
              "element": "literal",
              "content": [
                "typeof [1, 2]"
              ]
            },
            ", this produces ",
            {
              "element": "literal",
              "content": [
                "\"object\""
              ]
            },
            ". You can see them as long, flat octopuses with all their arms in a neat row, labeled with numbers."
          ]
        },
        {
          "element": "img",
          "src": "img/octopus-array.jpg"
        },
        {
          "element": "p",
          "content": [
            "So we can represent Jacques’ journal as an array of objects."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "var journal = [\n  {events: [\"work\", \"touched tree\", \"pizza\",\n            \"running\", \"television\"],\n   squirrel: false},\n  {events: [\"work\", \"ice cream\", \"cauliflower\",\n            \"lasagna\", \"touched tree\", \"brushed teeth\"],\n   squirrel: false},\n  {events: [\"weekend\", \"cycling\", \"break\",\n            \"peanuts\", \"beer\"],\n   squirrel: true},\n  /* and so on... */\n];"
        }
      ],
      "title": "Objects"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "We will get to actual programming ",
            {
              "element": "em",
              "content": [
                "real"
              ]
            },
            " soon now. But first, there’s one last piece of theory to understand."
          ]
        },
        {
          "element": "p",
          "content": [
            "We’ve seen that object values can be modified. The types of values discussed in earlier chapters, such as numbers, strings, and Booleans, are all ",
            {
              "element": "em",
              "content": [
                "immutable"
              ]
            },
            "—it is impossible to change an existing value of those types. You can combine them and derive new values from them, but when you take a specific string value, that value will always remain the same. The text inside it cannot be changed. If you have reference to a string that contains ",
            {
              "element": "literal",
              "content": [
                "\"cat\""
              ]
            },
            ", it is not possible for other code to change a character in ",
            {
              "element": "em",
              "content": [
                "that"
              ]
            },
            " string to make it spell ",
            {
              "element": "literal",
              "content": [
                "\"rat\""
              ]
            },
            "."
          ]
        },
        {
          "element": "p",
          "content": [
            "With objects, on the other hand, the content of a value ",
            {
              "element": "em",
              "content": [
                "can"
              ]
            },
            " be modified by changing its properties."
          ]
        },
        {
          "element": "p",
          "content": [
            "When we have two numbers, 120 and 120, we can consider them precisely the same number, whether or not they refer to the same physical bits. But with objects, there is a difference between having two references to the same object and having two different objects that contain the same properties. Consider the following code:"
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "var object1 = {value: 10};\nvar object2 = object1;\nvar object3 = {value: 10};\n\nconsole.log(object1 == object2);\n// → true\nconsole.log(object1 == object3);\n// → false\n\nobject1.value = 15;\nconsole.log(object2.value);\n// → 15\nconsole.log(object3.value);\n// → 10"
        },
        {
          "element": "p",
          "content": [
            "The ",
            {
              "element": "literal",
              "content": [
                "object1"
              ]
            },
            " and ",
            {
              "element": "literal",
              "content": [
                "object2"
              ]
            },
            " variables grasp the ",
            {
              "element": "em",
              "content": [
                "same"
              ]
            },
            " object, which is why changing ",
            {
              "element": "literal",
              "content": [
                "object1"
              ]
            },
            " also changes the value of ",
            {
              "element": "literal",
              "content": [
                "object2"
              ]
            },
            ". The variable ",
            {
              "element": "literal",
              "content": [
                "object3"
              ]
            },
            " points to a different object, which initially contains the same properties as ",
            {
              "element": "literal",
              "content": [
                "object1"
              ]
            },
            " but lives a separate life."
          ]
        },
        {
          "element": "p",
          "content": [
            "JavaScript’s ",
            {
              "element": "literal",
              "content": [
                "=="
              ]
            },
            " operator, when comparing objects, will return ",
            {
              "element": "literal",
              "content": [
                "true"
              ]
            },
            " only if both objects are precisely the same value. Comparing different objects will return ",
            {
              "element": "literal",
              "content": [
                "false"
              ]
            },
            ", even if they have identical contents. There is no “deep” comparison operation built into JavaScript, which looks at object’s contents, but it is possible to write it yourself (which will be one of the ",
            {
              "element": "reference",
              "content": [
                "exercises"
              ]
            },
            " at the end of this chapter)."
          ]
        }
      ],
      "title": "Mutability"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "So Jacques starts up his JavaScript interpreter and sets up the environment he needs to keep his journal."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "var journal = [];\n\nfunction addEntry(events, didITurnIntoASquirrel) {\n  journal.push({\n    events: events,\n    squirrel: didITurnIntoASquirrel\n  });\n}"
        },
        {
          "element": "p",
          "content": [
            "And then, every evening at ten—or sometimes the next morning, after climbing down from the top shelf of his bookcase—he records the day."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "addEntry([\"work\", \"touched tree\", \"pizza\", \"running\",\n          \"television\"], false);\naddEntry([\"work\", \"ice cream\", \"cauliflower\", \"lasagna\",\n          \"touched tree\", \"brushed teeth\"], false);\naddEntry([\"weekend\", \"cycling\", \"break\", \"peanuts\",\n          \"beer\"], true);"
        },
        {
          "element": "p",
          "content": [
            "Once he has enough data points, he intends to compute the correlation between his squirrelification and each of the day’s events and ideally learn something useful from those correlations."
          ]
        },
        {
          "element": "p",
          "content": [
            {
              "element": "em",
              "content": [
                "Correlation"
              ]
            },
            " is a measure of dependence between variables (“variables” in the statistical sense, not the JavaScript sense). It is usually expressed as a coefficient that ranges from -1 to 1. Zero correlation means the variables are not related, whereas a correlation of one indicates that the two are perfectly related—if you know one, you also know the other. Negative one also means that the variables are perfectly related but that they are opposites—when one is true, the other is false."
          ]
        },
        {
          "element": "p",
          "content": [
            "For binary (Boolean) variables, the ",
            {
              "element": "em",
              "content": [
                "phi"
              ]
            },
            " coefficient (",
            {
              "element": "em",
              "content": [
                "ϕ"
              ]
            },
            ") provides a good measure of correlation and is relatively easy to compute. To compute ",
            {
              "element": "em",
              "content": [
                "ϕ"
              ]
            },
            ", we need a table ",
            {
              "element": "em",
              "content": [
                "n"
              ]
            },
            " that contains the number of times the various combinations of the two variables were observed. For example, we could take the event of eating pizza and put that in a table like this:"
          ]
        },
        {
          "element": "img",
          "src": "img/pizza-squirrel.svg"
        },
        {
          "element": "p",
          "content": [
            {
              "element": "em",
              "content": [
                "ϕ"
              ]
            },
            " can be computed using the following formula, where ",
            {
              "element": "em",
              "content": [
                "n"
              ]
            },
            " refers to the table:"
          ]
        },
        {
          "element": "p",
          "content": [
            "The notation ",
            {
              "element": "em",
              "content": [
                "n"
              ]
            },
            " indicates the number of measurements where the first variable (squirrelness) is false (0) and the second variable (pizza) is true (1). In this example, ",
            {
              "element": "em",
              "content": [
                "n"
              ]
            },
            " is 9."
          ]
        },
        {
          "element": "p",
          "content": [
            "The value ",
            {
              "element": "em",
              "content": [
                "n"
              ]
            },
            " refers to the sum of all measurements where the first variable is true, which is 5 in the example table. Likewise, ",
            {
              "element": "em",
              "content": [
                "n"
              ]
            },
            " refers to the sum of the measurements where the second variable is false."
          ]
        },
        {
          "element": "p",
          "content": [
            "So for the pizza table, the part above the division line (the dividend) would be 1×76 - 4×9 = 40, and the part below it (the divisor) would be the square root of 5×85×10×80, or √340000. This comes out to ",
            {
              "element": "em",
              "content": [
                "ϕ"
              ]
            },
            " ≈ 0.069, which is tiny. Eating pizza does not appear to have influence on the transformations."
          ]
        }
      ],
      "title": "s log"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            " We can represent a two-by-two table in JavaScript with a four-element array (",
            {
              "element": "literal",
              "content": [
                "[76, 9,4, 1]"
              ]
            },
            "). We could also use other representations, such as an array containing two two-element arrays (",
            {
              "element": "literal",
              "content": [
                "[[76, 9], [4, 1]]"
              ]
            },
            ") or an object with property names like ",
            {
              "element": "literal",
              "content": [
                "\"11\""
              ]
            },
            " and ",
            {
              "element": "literal",
              "content": [
                "\"01\""
              ]
            },
            ", but the flat array is simple and makes the expressions that access the table pleasantly short. We’ll interpret the indices to the array as two-bit binary number, where the leftmost (most significant) digit refers to the squirrel variable and the rightmost (least significant) digit refers to the event variable. For example, the binary number ",
            {
              "element": "literal",
              "content": [
                "10"
              ]
            },
            " refers to the case where Jacques did turn into a squirrel, but the event (say, \"pizza\") didn’t occur. This happened four times. And since binary ",
            {
              "element": "literal",
              "content": [
                "10"
              ]
            },
            " is 2 in decimal notation, we will store this number at index 2 of the array."
          ]
        },
        {
          "element": "p",
          "content": [
            "This is the function that computes the ",
            {
              "element": "em",
              "content": [
                "ϕ"
              ]
            },
            " coefficient from such an array:"
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "function phi(table) {\n  return (table[3] * table[0] - table[2] * table[1]) /\n    Math.sqrt((table[2] + table[3]) *\n              (table[0] + table[1]) *\n              (table[1] + table[3]) *\n              (table[0] + table[2]));\n}\n\nconsole.log(phi([76, 9, 4, 1]));\n// → 0.068599434"
        },
        {
          "element": "p",
          "content": [
            "This is simply a direct translation of the ",
            {
              "element": "em",
              "content": [
                "ϕ"
              ]
            },
            " formula into JavaScript. ",
            {
              "element": "literal",
              "content": [
                "Math.sqrt"
              ]
            },
            " is the square root function, as provided by the ",
            {
              "element": "literal",
              "content": [
                "Math"
              ]
            },
            " object in a standard JavaScript environment. We have to sum two fields from the table to get fields like n because the sums of rows or columns are not stored directly in our data structure."
          ]
        },
        {
          "element": "p",
          "content": [
            "Jacques kept his journal for three months. The resulting data set is available in the coding sandbox for this chapter, where it is stored in the ",
            {
              "element": "literal",
              "content": [
                "JOURNAL"
              ]
            },
            " variable, and in a downloadable ",
            {
              "element": "reference",
              "content": [
                "file"
              ]
            },
            "."
          ]
        },
        {
          "element": "p",
          "content": [
            "To extract a two-by-two table for a specific event from this journal, we must loop over all the entries and tally up how many times the event occurs in relation to squirrel transformations."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "function hasEvent(event, entry) {\n  return entry.events.indexOf(event) != -1;\n}\n\nfunction tableFor(event, journal) {\n  var table = [0, 0, 0, 0];\n  for (var i = 0; i < journal.length; i++) {\n    var entry = journal[i], index = 0;\n    if (hasEvent(event, entry)) index += 1;\n    if (entry.squirrel) index += 2;\n    table[index] += 1;\n  }\n  return table;\n}\n\nconsole.log(tableFor(\"pizza\", JOURNAL));\n// → [76, 9, 4, 1]"
        },
        {
          "element": "p",
          "content": [
            "The ",
            {
              "element": "literal",
              "content": [
                "hasEvent"
              ]
            },
            " function tests whether an entry contains a given event. Arrays have an ",
            {
              "element": "literal",
              "content": [
                "indexOf"
              ]
            },
            " method that tries to find a given value (in this case, the event name) in the array and returns the index at which it was found or -1 if it wasn’t found. So if the call to ",
            {
              "element": "literal",
              "content": [
                "indexOf"
              ]
            },
            " doesn’t return -1, then we know the event was found in the entry."
          ]
        },
        {
          "element": "p",
          "content": [
            "The body of the loop in ",
            {
              "element": "literal",
              "content": [
                "tableFor"
              ]
            },
            " figures out which box in the table each journal entry falls into by checking whether the entry contains the specific event it’s interested in and whether the event happens alongside a squirrel incident. The loop then adds one to the number in the array that corresponds to this box on the table."
          ]
        },
        {
          "element": "p",
          "content": [
            "We now have the tools we need to compute individual correlations. The only step remaining is to find a correlation for every type of event that was recorded and see whether anything stands out. But how should we store these correlations once we compute them?"
          ]
        }
      ],
      "title": "Computing correlation"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "One possible way is to store all the correlations in an array, using objects with ",
            {
              "element": "literal",
              "content": [
                "name"
              ]
            },
            " and ",
            {
              "element": "literal",
              "content": [
                "value"
              ]
            },
            " properties. But that makes looking up the correlation for a given event somewhat cumbersome: you’d have to loop over the whole array to find the object with the right ",
            {
              "element": "literal",
              "content": [
                "name"
              ]
            },
            ". We could wrap this lookup process in a function, but we would still be writing more code, and the computer would be doing more work than necessary."
          ]
        },
        {
          "element": "p",
          "content": [
            "A better way is to use object properties named after the event types. We can use the square bracket access notation to create and read the properties and can use the ",
            {
              "element": "literal",
              "content": [
                "in"
              ]
            },
            " operator to test whether a given property exists."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "var map = {};\nfunction storePhi(event, phi) {\n  map[event] = phi;\n}\n\nstorePhi(\"pizza\", 0.069);\nstorePhi(\"touched tree\", -0.081);\nconsole.log(\"pizza\" in map);\n// → true\nconsole.log(map[\"touched tree\"]);\n// → -0.081"
        },
        {
          "element": "p",
          "content": [
            "A ",
            {
              "element": "em",
              "content": [
                "map"
              ]
            },
            " is a way to go from values in one domain (in this case, event names) to corresponding values in another domain (in this case, ",
            {
              "element": "em",
              "content": [
                "ϕ"
              ]
            },
            " coefficients)."
          ]
        },
        {
          "element": "p",
          "content": [
            "There are a few potential problems with using objects like this, which we will discuss in ",
            {
              "element": "reference",
              "content": [
                "Chapter 6"
              ]
            },
            ", but for the time being, we won’t worry about those."
          ]
        },
        {
          "element": "p",
          "content": [
            "What if we want to find all the events for which we have stored a coefficient? The properties don’t form a predictable series, like they would in an array, so we cannot use a normal ",
            {
              "element": "literal",
              "content": [
                "for"
              ]
            },
            " loop. JavaScript provides a loop construct specifically for going over the properties of an object. It looks a little like a normal ",
            {
              "element": "literal",
              "content": [
                "for"
              ]
            },
            " loop but distinguishes itself by the use of the word ",
            {
              "element": "literal",
              "content": [
                "in"
              ]
            },
            "."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "for (var event in map)\n  console.log(\"The correlation for '\" + event +\n              \"' is \" + map[event]);\n// → The correlation for 'pizza' is 0.069\n// → The correlation for 'touched tree' is -0.081"
        }
      ],
      "title": "Objects as maps"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "To find all the types of events that are present in the data set, we simply process each entry in turn and then loop over the events in that entry. We keep an object ",
            {
              "element": "literal",
              "content": [
                "phis"
              ]
            },
            " that has correlation coefficients for all the event types we have seen so far. Whenever we run across a type that isn’t in the ",
            {
              "element": "literal",
              "content": [
                "phis"
              ]
            },
            " object yet, we compute its correlation and add it to the object."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "function gatherCorrelations(journal) {\n  var phis = {};\n  for (var entry = 0; entry < journal.length; entry++) {\n    var events = journal[entry].events;\n    for (var i = 0; i < events.length; i++) {\n      var event = events[i];\n      if (!(event in phis))\n        phis[event] = phi(tableFor(event, journal));\n    }\n  }\n  return phis;\n}\n\nvar correlations = gatherCorrelations(JOURNAL);\nconsole.log(correlations.pizza);\n// → 0.068599434"
        },
        {
          "element": "p",
          "content": [
            "Let’s see what came out."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "for (var event in correlations)\n  console.log(event + \": \" + correlations[event]);\n// → carrot:   0.0140970969\n// → exercise: 0.0685994341\n// → weekend:  0.1371988681\n// → bread:   -0.0757554019\n// → pudding: -0.0648203724\n// and so on..."
        },
        {
          "element": "p",
          "content": [
            "Most correlations seem to lie close to zero. Eating carrots, bread, or pudding apparently does not trigger squirrel-lycanthropy. It ",
            {
              "element": "em",
              "content": [
                "does"
              ]
            },
            " seem to occur somewhat more often on weekends, however. Let’s filter the results to show only correlations greater than 0.1 or less than -0.1."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "for (var event in correlations) {\n  var correlation = correlations[event];\n  if (correlation > 0.1 || correlation < -0.1)\n    console.log(event + \": \" + correlation);\n}\n// → weekend:        0.1371988681\n// → brushed teeth: -0.3805211953\n// → candy:          0.1296407447\n// → work:          -0.1371988681\n// → spaghetti:      0.2425356250\n// → reading:        0.1106828054\n// → peanuts:        0.5902679812"
        },
        {
          "element": "p",
          "content": [
            "A-ha! There are two factors whose correlation is clearly stronger than the others. Eating peanuts has a strong positive effect on the chance of turning into a squirrel, whereas brushing his teeth has a significant negative effect."
          ]
        },
        {
          "element": "p",
          "content": [
            "Interesting. Let’s try something."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "for (var i = 0; i < JOURNAL.length; i++) {\n  var entry = JOURNAL[i];\n  if (hasEvent(\"peanuts\", entry) &&\n     !hasEvent(\"brushed teeth\", entry))\n    entry.events.push(\"peanut teeth\");\n}\nconsole.log(phi(tableFor(\"peanut teeth\", JOURNAL)));\n// → 1"
        },
        {
          "element": "p",
          "content": [
            "Well, that’s unmistakable! The phenomenon occurs precisely when Jacques eats peanuts and fails to brush his teeth. If only he weren’t such a slob about dental hygiene, he’d have never even noticed his affliction."
          ]
        },
        {
          "element": "p",
          "content": [
            "Knowing this, Jacques simply stops eating peanuts altogether and finds that this completely puts an end to his transformations."
          ]
        },
        {
          "element": "p",
          "content": [
            "All is well with Jacques for a while. But a few years later, he loses his job and is eventually forced to take employment with a circus, where he performs as ",
            {
              "element": "em",
              "content": [
                "The IncredibleSquirrelman"
              ]
            },
            " by stuffing his mouth with peanut butter before every show. One day, fed up with this pitiful existence, Jacques fails to change back into his human form, hops through a crack in the circus tent, and vanishes into the forest. He is never seen again."
          ]
        }
      ],
      "title": "The final analysis"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "Before finishing up this chapter, I want to introduce you to a few more object-related concepts. We’ll start by introducing some generally useful array methods."
          ]
        },
        {
          "element": "p",
          "content": [
            "We saw ",
            {
              "element": "literal",
              "content": [
                "push"
              ]
            },
            " and ",
            {
              "element": "literal",
              "content": [
                "pop"
              ]
            },
            ", which add and remove elements at the end of an array, ",
            {
              "element": "reference",
              "content": [
                "earlier"
              ]
            },
            " in this chapter. The corresponding methods for adding and removing things at the start of an array are called ",
            {
              "element": "literal",
              "content": [
                "unshift"
              ]
            },
            " and ",
            {
              "element": "literal",
              "content": [
                "shift"
              ]
            },
            "."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "var todoList = [];\nfunction rememberTo(task) {\n  todoList.push(task);\n}\nfunction whatIsNext() {\n  return todoList.shift();\n}\nfunction urgentlyRememberTo(task) {\n  todoList.unshift(task);\n}"
        },
        {
          "element": "p",
          "content": [
            "The previous program manages lists of tasks. You add tasks to the end of the list by calling ",
            {
              "element": "literal",
              "content": [
                "rememberTo(\"eat\")"
              ]
            },
            ", and when you’re ready to do something, you call ",
            {
              "element": "literal",
              "content": [
                "whatIsNext()"
              ]
            },
            " to get (and remove) the front item from the list. The ",
            {
              "element": "literal",
              "content": [
                "urgentlyRememberTo"
              ]
            },
            " function also adds a task but adds it to the front instead of the back of the list."
          ]
        },
        {
          "element": "p",
          "content": [
            "The ",
            {
              "element": "literal",
              "content": [
                "indexOf"
              ]
            },
            " method has a sibling called ",
            {
              "element": "literal",
              "content": [
                "lastIndexOf"
              ]
            },
            ", which starts searching for the given element at the end of the array instead of the front."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "console.log([1, 2, 3, 2, 1].indexOf(2));\n// → 1\nconsole.log([1, 2, 3, 2, 1].lastIndexOf(2));\n// → 3"
        },
        {
          "element": "p",
          "content": [
            "Both ",
            {
              "element": "literal",
              "content": [
                "indexOf"
              ]
            },
            " and ",
            {
              "element": "literal",
              "content": [
                "lastIndexOf"
              ]
            },
            " take an optional second argument that indicates where to start searching from."
          ]
        },
        {
          "element": "p",
          "content": [
            "Another fundamental method is ",
            {
              "element": "literal",
              "content": [
                "slice"
              ]
            },
            ", which takes a start index and an end index and returns an array that has only the elements between those indices. The start index is inclusive, the end index exclusive."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "console.log([0, 1, 2, 3, 4].slice(2, 4));\n// → [2, 3]\nconsole.log([0, 1, 2, 3, 4].slice(2));\n// → [2, 3, 4]"
        },
        {
          "element": "p",
          "content": [
            "When the end index is not given, ",
            {
              "element": "literal",
              "content": [
                "slice"
              ]
            },
            " will take all of the elements after the start index. Strings also have a ",
            {
              "element": "literal",
              "content": [
                "slice"
              ]
            },
            " method, which has a similar effect."
          ]
        },
        {
          "element": "p",
          "content": [
            "The ",
            {
              "element": "literal",
              "content": [
                "concat"
              ]
            },
            " method can be used to glue arrays together, similar to what the ",
            {
              "element": "literal",
              "content": [
                "+"
              ]
            },
            " operator does for strings. The following example shows both ",
            {
              "element": "literal",
              "content": [
                "concat"
              ]
            },
            " and ",
            {
              "element": "literal",
              "content": [
                "slice"
              ]
            },
            " in action. It takes an array and an index, and it returns a new array that is a copy of the original array with the element at the given index removed."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "function remove(array, index) {\n  return array.slice(0, index)\n    .concat(array.slice(index + 1));\n}\nconsole.log(remove([\"a\", \"b\", \"c\", \"d\", \"e\"], 2));\n// → [\"a\", \"b\", \"d\", \"e\"]"
        }
      ],
      "title": "Further arrayology"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "We can read properties like ",
            {
              "element": "literal",
              "content": [
                "length"
              ]
            },
            " and ",
            {
              "element": "literal",
              "content": [
                "toUpperCase"
              ]
            },
            " from string values. But if you try to add a new property, it doesn’t stick."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "var myString = \"Fido\";\nmyString.myProperty = \"value\";\nconsole.log(myString.myProperty);\n// → undefined"
        },
        {
          "element": "p",
          "content": [
            "Values of type string, number, and Boolean are not objects, and though the language doesn’t complain if you try to set new properties on them, it doesn’t actually store those properties. The values are immutable and cannot be changed."
          ]
        },
        {
          "element": "p",
          "content": [
            " But these types do have some built-in properties. Every string value has a number of methods. The most useful ones are probably ",
            {
              "element": "literal",
              "content": [
                "slice"
              ]
            },
            " and ",
            {
              "element": "literal",
              "content": [
                "indexOf"
              ]
            },
            ", which resemble the array methods of the same name."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "console.log(\"coconuts\".slice(4, 7));\n// → nut\nconsole.log(\"coconut\".indexOf(\"u\"));\n// → 5"
        },
        {
          "element": "p",
          "content": [
            "One difference is that a string’s ",
            {
              "element": "literal",
              "content": [
                "indexOf"
              ]
            },
            " can take a string containing more than one character, whereas the corresponding array method looks only for a single element."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "console.log(\"one two three\".indexOf(\"ee\"));\n// → 11"
        },
        {
          "element": "p",
          "content": [
            "The ",
            {
              "element": "literal",
              "content": [
                "trim"
              ]
            },
            " method removes whitespace (spaces, newlines, tabs, and similar characters) from the start and end of a string."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "console.log(\"  okay \\n \".trim());\n// → okay"
        },
        {
          "element": "p",
          "content": [
            " We have already seen the string type’s ",
            {
              "element": "literal",
              "content": [
                "length"
              ]
            },
            " property. Accessing the individual characters in a string can be done with the ",
            {
              "element": "literal",
              "content": [
                "charAt"
              ]
            },
            " method but also by simply reading numeric properties, like you’d do for an array."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "var string = \"abc\";\nconsole.log(string.length);\n// → 3\nconsole.log(string.charAt(0));\n// → a\nconsole.log(string[1]);\n// → b"
        }
      ],
      "title": "Strings and their properties"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "Whenever a function is called, a special variable named ",
            {
              "element": "literal",
              "content": [
                "arguments"
              ]
            },
            " is added to the environment in which the function body runs. This variable refers to an object that holds all of the arguments passed to the function. Remember that in JavaScript you are allowed to pass more (or fewer) arguments to a function than the number of parameters the function itself declares."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "function noArguments() {}\nnoArguments(1, 2, 3); // This is okay\nfunction threeArguments(a, b, c) {}\nthreeArguments(); // And so is this"
        },
        {
          "element": "p",
          "content": [
            "The ",
            {
              "element": "literal",
              "content": [
                "arguments"
              ]
            },
            " object has a ",
            {
              "element": "literal",
              "content": [
                "length"
              ]
            },
            " property that tells us the number of arguments that were really passed to the function. It also has a property for each argument, named 0, 1, 2, and so on."
          ]
        },
        {
          "element": "p",
          "content": [
            "If that sounds a lot like an array to you, you’re right, it ",
            {
              "element": "em",
              "content": [
                "is"
              ]
            },
            " a lot like an array. But this object, unfortunately, does not have any array methods (like ",
            {
              "element": "literal",
              "content": [
                "slice"
              ]
            },
            " or ",
            {
              "element": "literal",
              "content": [
                "indexOf"
              ]
            },
            "), so it is a little harder to use than a real array."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "function argumentCounter() {\n  console.log(\"You gave me\", arguments.length, \"arguments.\");\n}\nargumentCounter(\"Straw man\", \"Tautology\", \"Ad hominem\");\n// → You gave me 3 arguments."
        },
        {
          "element": "p",
          "content": [
            "Some functions can take any number of arguments, like ",
            {
              "element": "literal",
              "content": [
                "console.log"
              ]
            },
            ". These typically loop over the values in their ",
            {
              "element": "literal",
              "content": [
                "arguments"
              ]
            },
            " object. They can be used to create very pleasant interfaces. For example, remember how we created the entries to Jacques’ journal."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "addEntry([\"work\", \"touched tree\", \"pizza\", \"running\",\n          \"television\"], false);"
        },
        {
          "element": "p",
          "content": [
            "Since he is going to be calling this function a lot, we could create an alternative that is easier to call."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "function addEntry(squirrel) {\n  var entry = {events: [], squirrel: squirrel};\n  for (var i = 1; i < arguments.length; i++)\n    entry.events.push(arguments[i]);\n  journal.push(entry);\n}\naddEntry(true, \"work\", \"touched tree\", \"pizza\",\n         \"running\", \"television\");"
        },
        {
          "element": "p",
          "content": [
            "This version reads its first argument (",
            {
              "element": "literal",
              "content": [
                "squirrel"
              ]
            },
            ") in the normal way and then goes over the rest of the arguments (the loop starts at index 1, skipping the first) to gather them into an array."
          ]
        }
      ],
      "title": "The arguments object"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "As we’ve seen, ",
            {
              "element": "literal",
              "content": [
                "Math"
              ]
            },
            " is a grab-bag of number-related utility functions, such as ",
            {
              "element": "literal",
              "content": [
                "Math.max"
              ]
            },
            " (maximum), ",
            {
              "element": "literal",
              "content": [
                "Math.min"
              ]
            },
            " (minimum), and ",
            {
              "element": "literal",
              "content": [
                "Math.sqrt"
              ]
            },
            " (square root)."
          ]
        },
        {
          "element": "p",
          "content": [
            "The ",
            {
              "element": "literal",
              "content": [
                "Math"
              ]
            },
            " object is used simply as a container to group a bunch of related functionality. There is only one ",
            {
              "element": "literal",
              "content": [
                "Math"
              ]
            },
            " object, and it is almost never useful as a value. Rather, it provides a ",
            {
              "element": "em",
              "content": [
                "namespace"
              ]
            },
            " so that all these functions and values do not have to be global variables."
          ]
        },
        {
          "element": "p",
          "content": [
            "Having too many global variables “pollutes” the namespace. The more names that have been taken, the more likely you are to accidentally overwrite the value of some variable. For example, it’s not unlikely that you’ll want to name something ",
            {
              "element": "literal",
              "content": [
                "max"
              ]
            },
            " in one of your programs. Since JavaScript’s built-in ",
            {
              "element": "literal",
              "content": [
                "max"
              ]
            },
            " function is tucked safely inside the ",
            {
              "element": "literal",
              "content": [
                "Math"
              ]
            },
            " object, we don’t have to worry about overwriting it."
          ]
        },
        {
          "element": "p",
          "content": [
            "Many languages will stop you, or at least warn you, when you are defining a variable with a name that is already taken. JavaScript does neither, so be careful."
          ]
        },
        {
          "element": "p",
          "content": [
            "Back to the ",
            {
              "element": "literal",
              "content": [
                "Math"
              ]
            },
            " object. If you need to do trigonometry, ",
            {
              "element": "literal",
              "content": [
                "Math"
              ]
            },
            " can help. It contains ",
            {
              "element": "literal",
              "content": [
                "cos"
              ]
            },
            " (cosine), ",
            {
              "element": "literal",
              "content": [
                "sin"
              ]
            },
            " (sine), and ",
            {
              "element": "literal",
              "content": [
                "tan"
              ]
            },
            " (tangent), as well as their inverse functions, ",
            {
              "element": "literal",
              "content": [
                "acos"
              ]
            },
            ", ",
            {
              "element": "literal",
              "content": [
                "asin"
              ]
            },
            ", and ",
            {
              "element": "literal",
              "content": [
                "atan"
              ]
            },
            ", respectively. The number π (pi)—or at least the closest approximation that fits in a JavaScript number—is available as ",
            {
              "element": "literal",
              "content": [
                "Math.PI"
              ]
            },
            ". (There is an old programming tradition of writing the names of constant values in all caps.)"
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "function randomPointOnCircle(radius) {\n  var angle = Math.random() * 2 * Math.PI;\n  return {x: radius * Math.cos(angle),\n          y: radius * Math.sin(angle)};\n}\nconsole.log(randomPointOnCircle(2));\n// → {x: 0.3667, y: 1.966}"
        },
        {
          "element": "p",
          "content": [
            "If sines and cosines are not something you are very familiar with, don’t worry. When they are used in this book, in ",
            {
              "element": "reference",
              "content": [
                "Chapter 13"
              ]
            },
            ", I’ll explain them."
          ]
        },
        {
          "element": "p",
          "content": [
            "The previous example uses ",
            {
              "element": "literal",
              "content": [
                "Math.random"
              ]
            },
            ". This is a function that returns a new pseudorandom number between zero (inclusive) and one (exclusive) every time you call it."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "console.log(Math.random());\n// → 0.36993729369714856\nconsole.log(Math.random());\n// → 0.727367032552138\nconsole.log(Math.random());\n// → 0.40180766698904335"
        },
        {
          "element": "p",
          "content": [
            "Though computers are deterministic machines—they always react the same way if given the same input—it is possible to have them produce numbers that appear random. To do this, the machine keeps a number (or a bunch of numbers) in its internal state. Then, every time a random number is requested, it performs some complicated deterministic computations on this internal state and returns part of the result of those computations. The machine also uses the outcome to change its own internal state so that the next “random” number produced will be different."
          ]
        },
        {
          "element": "p",
          "content": [
            "If we want a whole random number instead of a fractional one, we can use ",
            {
              "element": "literal",
              "content": [
                "Math.floor"
              ]
            },
            " (which rounds down to the nearest whole number) on the result of ",
            {
              "element": "literal",
              "content": [
                "Math.random"
              ]
            },
            "."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "console.log(Math.floor(Math.random() * 10));\n// → 2"
        },
        {
          "element": "p",
          "content": [
            "Multiplying the random number by 10 gives us a number greater than or equal to zero, and below 10. Since ",
            {
              "element": "literal",
              "content": [
                "Math.floor"
              ]
            },
            " rounds down, this expression will produce, with equal chance, any number from 0 through 9."
          ]
        },
        {
          "element": "p",
          "content": [
            "There are also the functions ",
            {
              "element": "literal",
              "content": [
                "Math.ceil"
              ]
            },
            " (for “ceiling”, which rounds up to a whole number) and ",
            {
              "element": "literal",
              "content": [
                "Math.round"
              ]
            },
            " (to the nearest whole number)."
          ]
        }
      ],
      "title": "The Math object"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "The global scope, the space in which global variables live, can also be approached as an object in JavaScript. Each global variable is present as a property of this object. In browsers, the global scope object is stored in the ",
            {
              "element": "literal",
              "content": [
                "window"
              ]
            },
            " variable."
          ]
        },
        {
          "element": "listing",
          "numbered": false,
          "content": "var myVar = 10;\nconsole.log(\"myVar\" in window);\n// → true\nconsole.log(window.myVar);\n// → 10"
        }
      ],
      "title": "The global object"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "p",
          "content": [
            "Objects and arrays (which are a specific kind of object) provide ways to group several values into a single value. Conceptually, this allows us to put a bunch of related things in a bag and run around with the bag, instead of trying to wrap our arms around all of the individual things and trying to hold on to them separately."
          ]
        },
        {
          "element": "p",
          "content": [
            "Most values in JavaScript have properties, the exceptions being ",
            {
              "element": "literal",
              "content": [
                "null"
              ]
            },
            " and ",
            {
              "element": "literal",
              "content": [
                "undefined"
              ]
            },
            ". Properties are accessed using ",
            {
              "element": "literal",
              "content": [
                "value.propName"
              ]
            },
            " or ",
            {
              "element": "literal",
              "content": [
                "value[\"propName\"]"
              ]
            },
            ". Objects tend to use names for their properties and store more or less a fixed set of them. Arrays, on the other hand, usually contain varying numbers of conceptually identical values and use numbers (starting from 0) as the names of their properties."
          ]
        },
        {
          "element": "p",
          "content": [
            "There ",
            {
              "element": "em",
              "content": [
                "are"
              ]
            },
            " some named properties in arrays, such as ",
            {
              "element": "literal",
              "content": [
                "length"
              ]
            },
            " and a number of methods. Methods are functions that live in properties and (usually) act on the value they are a property of."
          ]
        },
        {
          "element": "p",
          "content": [
            "Objects can also serve as maps, associating values with names. The ",
            {
              "element": "literal",
              "content": [
                "in"
              ]
            },
            " operator can be used to find out whether an object contains a property with a given name. The same keyword can also be used in a ",
            {
              "element": "literal",
              "content": [
                "for"
              ]
            },
            " loop (",
            {
              "element": "literal",
              "content": [
                "for (var name in object)"
              ]
            },
            ") to loop over an object’s properties."
          ]
        }
      ],
      "title": "Summary"
    },
    {
      "element": "section",
      "content": [
        {
          "element": "section",
          "content": [
            {
              "element": "p",
              "content": [
                "The ",
                {
                  "element": "reference",
                  "content": [
                    "introduction"
                  ]
                },
                " of this book alluded to the following as a nice way to compute the sum of a range of numbers:"
              ]
            },
            {
              "element": "listing",
              "numbered": false,
              "content": "console.log(sum(range(1, 10)));"
            },
            {
              "element": "p",
              "content": [
                "Write a ",
                {
                  "element": "literal",
                  "content": [
                    "range"
                  ]
                },
                " function that takes two arguments, ",
                {
                  "element": "literal",
                  "content": [
                    "start"
                  ]
                },
                " and ",
                {
                  "element": "literal",
                  "content": [
                    "end"
                  ]
                },
                ", and returns an array containing all the numbers from ",
                {
                  "element": "literal",
                  "content": [
                    "start"
                  ]
                },
                " up to (and including) ",
                {
                  "element": "literal",
                  "content": [
                    "end"
                  ]
                },
                "."
              ]
            },
            {
              "element": "p",
              "content": [
                "Next, write a ",
                {
                  "element": "literal",
                  "content": [
                    "sum"
                  ]
                },
                " function that takes an array of numbers and returns the sum of these numbers. Run the previous program and see whether it does indeed return 55."
              ]
            },
            {
              "element": "p",
              "content": [
                "As a bonus assignment, modify your ",
                {
                  "element": "literal",
                  "content": [
                    "range"
                  ]
                },
                " function to take an optional third argument that indicates the “step” value used to build up the array. If no step is given, the array elements go up by increments of one, corresponding to the old behavior. The function call ",
                {
                  "element": "literal",
                  "content": [
                    "range(1, 10, 2)"
                  ]
                },
                " should return ",
                {
                  "element": "literal",
                  "content": [
                    "[1, 3, 5,7, 9]"
                  ]
                },
                ". Make sure it also works with negative step values so that ",
                {
                  "element": "literal",
                  "content": [
                    "range(5, 2, -1)"
                  ]
                },
                " produces ",
                {
                  "element": "literal",
                  "content": [
                    "[5, 4, 3, 2]"
                  ]
                },
                "."
              ]
            },
            {
              "element": "hint",
              "content": [
                {
                  "element": "p",
                  "content": [
                    "Building up an array is most easily done by first initializing a variable to ",
                    {
                      "element": "literal",
                      "content": [
                        "[]"
                      ]
                    },
                    " (a fresh, empty array) and repeatedly calling its ",
                    {
                      "element": "literal",
                      "content": [
                        "push"
                      ]
                    },
                    " method to add a value. Don’t forget to return the array at the end of the function."
                  ]
                },
                {
                  "element": "p",
                  "content": [
                    "Since the end boundary is inclusive, you’ll need to use the ",
                    {
                      "element": "literal",
                      "content": [
                        "<="
                      ]
                    },
                    " operator rather than simply ",
                    {
                      "element": "literal",
                      "content": [
                        "<"
                      ]
                    },
                    " to check for the end of your loop."
                  ]
                },
                {
                  "element": "p",
                  "content": [
                    "To check whether the optional step argument was given, either check ",
                    {
                      "element": "literal",
                      "content": [
                        "arguments.length"
                      ]
                    },
                    " or compare the value of the argument to ",
                    {
                      "element": "literal",
                      "content": [
                        "undefined"
                      ]
                    },
                    ". If it wasn’t given, simply set it to its default value (1) at the top of the function."
                  ]
                },
                {
                  "element": "p",
                  "content": [
                    "Having ",
                    {
                      "element": "literal",
                      "content": [
                        "range"
                      ]
                    },
                    " understand negative step values is probably best done by writing two separate loops—one for counting up and one for counting down—because the comparison that checks whether the loop is finished needs to be ",
                    {
                      "element": "literal",
                      "content": [
                        ">="
                      ]
                    },
                    " rather than ",
                    {
                      "element": "literal",
                      "content": [
                        "<="
                      ]
                    },
                    " when counting downward."
                  ]
                },
                {
                  "element": "p",
                  "content": [
                    "It might also be worthwhile to use a different default step, namely, -1, when the end of the range is smaller than the start. That way, ",
                    {
                      "element": "literal",
                      "content": [
                        "range(5, 2)"
                      ]
                    },
                    " returns something meaningful, rather than getting stuck in an infinite loop."
                  ]
                }
              ]
            }
          ],
          "title": "The sum of a range"
        },
        {
          "element": "section",
          "content": [
            {
              "element": "p",
              "content": [
                "Arrays have a method ",
                {
                  "element": "literal",
                  "content": [
                    "reverse"
                  ]
                },
                ", which changes the array by inverting the order in which its elements appear. For this exercise, write two functions, ",
                {
                  "element": "literal",
                  "content": [
                    "reverseArray"
                  ]
                },
                " and ",
                {
                  "element": "literal",
                  "content": [
                    "reverseArrayInPlace"
                  ]
                },
                ". The first, ",
                {
                  "element": "literal",
                  "content": [
                    "reverseArray"
                  ]
                },
                ", takes an array as argument and produces a ",
                {
                  "element": "em",
                  "content": [
                    "new"
                  ]
                },
                " array that has the same elements in the inverse order. The second, ",
                {
                  "element": "literal",
                  "content": [
                    "reverseArrayInPlace"
                  ]
                },
                ", does what the ",
                {
                  "element": "literal",
                  "content": [
                    "reverse"
                  ]
                },
                " method does: it modifies the array given as argument in order to reverse its elements. Neither may use the standard ",
                {
                  "element": "literal",
                  "content": [
                    "reverse"
                  ]
                },
                " method."
              ]
            },
            {
              "element": "p",
              "content": [
                "Thinking back to the notes about side effects and pure functions in the ",
                {
                  "element": "reference",
                  "content": [
                    "previous chapter"
                  ]
                },
                ", which variant do you expect to be useful in more situations? Which one is more efficient?"
              ]
            },
            {
              "element": "hint",
              "content": [
                {
                  "element": "p",
                  "content": [
                    "There are two obvious ways to implement ",
                    {
                      "element": "literal",
                      "content": [
                        "reverseArray"
                      ]
                    },
                    ". The first is to simply go over the input array from front to back and use the ",
                    {
                      "element": "literal",
                      "content": [
                        "unshift"
                      ]
                    },
                    " method on the new array to insert each element at its start. The second is to loop over the input array backward and use the ",
                    {
                      "element": "literal",
                      "content": [
                        "push"
                      ]
                    },
                    " method. Iterating over an array backward requires a (somewhat awkward) ",
                    {
                      "element": "literal",
                      "content": [
                        "for"
                      ]
                    },
                    " specification like ",
                    {
                      "element": "literal",
                      "content": [
                        "(var i =array.length - 1; i >= 0; i--)"
                      ]
                    },
                    "."
                  ]
                },
                {
                  "element": "p",
                  "content": [
                    "Reversing the array in place is harder. You have to be careful not to overwrite elements that you will later need. Using ",
                    {
                      "element": "literal",
                      "content": [
                        "reverseArray"
                      ]
                    },
                    " or otherwise copying the whole array (",
                    {
                      "element": "literal",
                      "content": [
                        "array.slice(0)"
                      ]
                    },
                    " is a good way to copy an array) works but is cheating."
                  ]
                },
                {
                  "element": "p",
                  "content": [
                    "The trick is to ",
                    {
                      "element": "em",
                      "content": [
                        "swap"
                      ]
                    },
                    " the first and last elements, then the second and second-to-last, and so on. You can do this by looping over half the length of the array (use ",
                    {
                      "element": "literal",
                      "content": [
                        "Math.floor"
                      ]
                    },
                    " to round down—you don’t need to touch the middle element in an array with an odd length) and swapping the element at position ",
                    {
                      "element": "literal",
                      "content": [
                        "i"
                      ]
                    },
                    " with the one at position ",
                    {
                      "element": "literal",
                      "content": [
                        "array.length - 1 - i"
                      ]
                    },
                    ". You can use a local variable to briefly hold on to one of the elements, overwrite that one with its mirror image, and then put the value from the local variable in the place where the mirror image used to be."
                  ]
                }
              ]
            }
          ],
          "title": "Reversing an array"
        },
        {
          "element": "section",
          "content": [
            {
              "element": "p",
              "content": [
                "Objects, as generic blobs of values, can be used to build all sorts of data structures. A common data structure is the ",
                {
                  "element": "em",
                  "content": [
                    "list"
                  ]
                },
                " (not to be confused with the array). A list is a nested set of objects, with the first object holding a reference to the second, the second to the third, and so on."
              ]
            },
            {
              "element": "listing",
              "numbered": false,
              "content": "var list = {\n  value: 1,\n  rest: {\n    value: 2,\n    rest: {\n      value: 3,\n      rest: null\n    }\n  }\n};"
            },
            {
              "element": "p",
              "content": [
                "The resulting objects form a chain, like this:"
              ]
            },
            {
              "element": "img",
              "src": "img/linked-list.svg"
            },
            {
              "element": "p",
              "content": [
                "A nice thing about lists is that they can share parts of their structure. For example, if I create two new values ",
                {
                  "element": "literal",
                  "content": [
                    "{value: 0, rest: list}"
                  ]
                },
                " and ",
                {
                  "element": "literal",
                  "content": [
                    "{value: -1, rest: list}"
                  ]
                },
                " (with ",
                {
                  "element": "literal",
                  "content": [
                    "list"
                  ]
                },
                " referring to the variable defined earlier), they are both independent lists, but they share the structure that makes up their last three elements. In addition, the original list is also still a valid three-element list."
              ]
            },
            {
              "element": "p",
              "content": [
                "Write a function ",
                {
                  "element": "literal",
                  "content": [
                    "arrayToList"
                  ]
                },
                " that builds up a data structure like the previous one when given ",
                {
                  "element": "literal",
                  "content": [
                    "[1, 2, 3]"
                  ]
                },
                " as argument, and write a ",
                {
                  "element": "literal",
                  "content": [
                    "listToArray"
                  ]
                },
                " function that produces an array from a list. Also write the helper functions ",
                {
                  "element": "literal",
                  "content": [
                    "prepend"
                  ]
                },
                ", which takes an element and a list and creates a new list that adds the element to the front of the input list, and ",
                {
                  "element": "literal",
                  "content": [
                    "nth"
                  ]
                },
                ", which takes a list and a number and returns the element at the given position in the list, or ",
                {
                  "element": "literal",
                  "content": [
                    "undefined"
                  ]
                },
                " when there is no such element."
              ]
            },
            {
              "element": "p",
              "content": [
                "If you haven’t already, also write a recursive version of ",
                {
                  "element": "literal",
                  "content": [
                    "nth"
                  ]
                },
                "."
              ]
            },
            {
              "element": "hint",
              "content": [
                {
                  "element": "p",
                  "content": [
                    "Building up a list is best done back to front. So ",
                    {
                      "element": "literal",
                      "content": [
                        "arrayToList"
                      ]
                    },
                    " could iterate over the array backward (see previous exercise) and, for each element, add an object to the list. You can use a local variable to hold the part of the list that was built so far and use a pattern like ",
                    {
                      "element": "literal",
                      "content": [
                        "list = {value: X, rest:list}"
                      ]
                    },
                    " to add an element."
                  ]
                },
                {
                  "element": "p",
                  "content": [
                    "To run over a list (in ",
                    {
                      "element": "literal",
                      "content": [
                        "listToArray"
                      ]
                    },
                    " and ",
                    {
                      "element": "literal",
                      "content": [
                        "nth"
                      ]
                    },
                    "), a ",
                    {
                      "element": "literal",
                      "content": [
                        "for"
                      ]
                    },
                    " loop specification like this can be used:"
                  ]
                },
                {
                  "element": "listing",
                  "numbered": false,
                  "content": "for (var node = list; node; node = node.rest) {}"
                },
                {
                  "element": "p",
                  "content": [
                    "Can you see how that works? Every iteration of the loop, ",
                    {
                      "element": "literal",
                      "content": [
                        "node"
                      ]
                    },
                    " points to the current sublist, and the body can read its ",
                    {
                      "element": "literal",
                      "content": [
                        "value"
                      ]
                    },
                    " property to get the current element. At the end of an iteration, ",
                    {
                      "element": "literal",
                      "content": [
                        "node"
                      ]
                    },
                    " moves to the next sublist. When that is null, we have reached the end of the list and the loop is finished."
                  ]
                },
                {
                  "element": "p",
                  "content": [
                    "The recursive version of ",
                    {
                      "element": "literal",
                      "content": [
                        "nth"
                      ]
                    },
                    " will, similarly, look at an ever smaller part of the “tail” of the list and at the same time count down the index until it reaches zero, at which point it can return the ",
                    {
                      "element": "literal",
                      "content": [
                        "value"
                      ]
                    },
                    " property of the node it is looking at. To get the zeroeth element of a list, you simply take the ",
                    {
                      "element": "literal",
                      "content": [
                        "value"
                      ]
                    },
                    " property of its head node. To get element ",
                    {
                      "element": "em",
                      "content": [
                        "N"
                      ]
                    },
                    " + 1, you take the ",
                    {
                      "element": "em",
                      "content": [
                        "N"
                      ]
                    },
                    "th element of the list that’s in this list’s ",
                    {
                      "element": "literal",
                      "content": [
                        "rest"
                      ]
                    },
                    " property."
                  ]
                }
              ]
            }
          ],
          "title": "A list"
        },
        {
          "element": "section",
          "content": [
            {
              "element": "p",
              "content": [
                "The ",
                {
                  "element": "literal",
                  "content": [
                    "=="
                  ]
                },
                " operator compares objects by identity. But sometimes, you would prefer to compare the values of their actual properties."
              ]
            },
            {
              "element": "p",
              "content": [
                "Write a function, ",
                {
                  "element": "literal",
                  "content": [
                    "deepEqual"
                  ]
                },
                ", that takes two values and returns true only if they are the same value or are objects with the same properties whose values are also equal when compared with a recursive call to ",
                {
                  "element": "literal",
                  "content": [
                    "deepEqual"
                  ]
                },
                "."
              ]
            },
            {
              "element": "p",
              "content": [
                "To find out whether to compare two things by identity (use the ",
                {
                  "element": "literal",
                  "content": [
                    "==="
                  ]
                },
                " operator for that) or by looking at their properties, you can use the ",
                {
                  "element": "literal",
                  "content": [
                    "typeof"
                  ]
                },
                " operator. If it produces ",
                {
                  "element": "literal",
                  "content": [
                    "\"object\""
                  ]
                },
                " for both values, you should do a deep comparison. But you have to take one silly exception into account: by a historical accident, ",
                {
                  "element": "literal",
                  "content": [
                    "typeof null"
                  ]
                },
                " also produces ",
                {
                  "element": "literal",
                  "content": [
                    "\"object\""
                  ]
                },
                "."
              ]
            },
            {
              "element": "hint",
              "content": [
                {
                  "element": "p",
                  "content": [
                    "Your test for whether you are dealing with a real object will look something like ",
                    {
                      "element": "literal",
                      "content": [
                        "typeof x == \"object\" && x !=null"
                      ]
                    },
                    ". Be careful to compare properties only when ",
                    {
                      "element": "em",
                      "content": [
                        "both"
                      ]
                    },
                    " arguments are objects. In all other cases you can just immediately return the result of applying ",
                    {
                      "element": "literal",
                      "content": [
                        "==="
                      ]
                    },
                    "."
                  ]
                },
                {
                  "element": "p",
                  "content": [
                    "Use a ",
                    {
                      "element": "literal",
                      "content": [
                        "for"
                      ]
                    },
                    "/",
                    {
                      "element": "literal",
                      "content": [
                        "in"
                      ]
                    },
                    " loop to go over the properties. You need to test whether both objects have the same set of property names and whether those properties have identical values. The first test can be done by counting the properties in both objects and returning false if the numbers of properties are different. If they’re the same, then go over the properties of one object, and for each of them, verify that the other object also has the property. The values of the properties are compared by a recursive call to ",
                    {
                      "element": "literal",
                      "content": [
                        "deepEqual"
                      ]
                    },
                    "."
                  ]
                },
                {
                  "element": "p",
                  "content": [
                    "Returning the correct value from the function is best done by immediately returning false when a mismatch is noticed and returning true at the end of the function."
                  ]
                }
              ]
            }
          ],
          "title": "Deep comparison"
        }
      ],
      "title": "Exercises"
    }
  ],
  "title": "Data Structures: Objects and Arrays"
}
